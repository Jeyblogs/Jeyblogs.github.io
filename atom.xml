<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jey</title>
  <subtitle>Keep Calm and Carry On</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.jeyblogs.com/"/>
  <updated>2017-02-23T09:03:09.000Z</updated>
  <id>http://www.jeyblogs.com/</id>
  
  <author>
    <name>Jey.yuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS面试题答案</title>
    <link href="http://www.jeyblogs.com/2016/10/28/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    <id>http://www.jeyblogs.com/2016/10/28/面试题答案/</id>
    <published>2016-10-28T15:20:38.000Z</published>
    <updated>2017-02-23T09:03:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>基础：<br>1.<br>2.ios中实现callback可以通过两种方法，委托和NSNotification<br>委托的话是一对一的关系，例如一个UIViewController里有一个tableView, 将该viewController设置为tableView的委托，tableView执行的时候调用委托的函数，同时可能需要得到反馈，比如tableView通过调用delegate中rowsOfSections函数来得到该tableView的行数，调用委托函数的时候也可能不需要反馈，例如UIApplication的在AppDelegate中的生命周期函数，还有UIScrollView的didScroll之类委托函数。委托的意思是有些方法不在类本身实现，而是在另一个类中实现。<br>NSNotification的话是一对多的关系，notification发出去以后发送方就不管了，接不接收以及接收后做什么发送方就不管了。</p>
<p>委托的实现：<br>一般来说通过delegate来实现，但是apple引入block后通过block也可以实现委托。二者区别是，如果有一堆接口的话可以用delegate，例如UITableView的delegate，因为它需要通过委托知tableView有多少个section，每个section有多少row，每个row的cell是什么；但是如果是调用方和block的执行结果有直接因果关系，用block就比较合适，例如UIView animation方法中的complete block，动画结束后直接执行block中的逻辑，当然complete block也可以通过delegate实现，实现方法是给UIView设定一个delegate，动画结束后UIView调用delegate中的方法。<br>ps：delegate实现的过程中需要指定的类来实现特定的protocol。<br>block, 本质是封装了一段代码，可以被当做对象使用(可以定义成Property)。<br>3.<br>static Singleton* _instance = nil;</p>
<p>+(instancetype) shareInstance<br>{<br>    static dispatch_once_t onceToken ;<br>    dispatch_once(&amp;onceToken, ^{<br>        _instance = [[super allocWithZone:NULL]() init] ;<br>    }) ;</p>
<pre><code>return _instance ;
</code></pre><p>}</p>
<p>+(id) allocWithZone:(struct _NSZone *)zone<br>{<br>    return <a href="">Singleton shareInstance</a> ;<br>}</p>
<p>-(id) copyWithZone:(struct _NSZone *)zone<br>{<br>    return <a href="">Singleton shareInstance</a> ;<br>}<br>4.<br>assign：用于对基本数据类型进行赋值操作，不更改引用计数。也可以用来修饰对象，但是，被assign修饰的对象在释放后，指针的地址还是存在的，也就是说指针并没有被置为nil，成为野指针。如果后续在分配对象到堆上的某块内存时，正好分到这块地址，程序就会crash。之所以可以修饰基本数据类型，因为基本数据类型一般分配在栈上，栈的内存会由系统自动处理，不会造成野指针。<br>weak：修饰Object类型，修饰的对象在释放后，指针地址会被置为nil，是一种弱引用。在ARC环境下，为避免循环引用，往往会把delegate属性用weak修饰；在MRC下使用assign修饰。weak和strong不同的是：当一个对象不再有strong类型的指针指向它的时候，它就会被释放，即使还有weak型指针指向它，那么这些weak型指针也将被清除。<br>ARC下的strong等同于MRC下的retain都会把对象引用计数加1。<br>copy：会在内存里拷贝一份对象，两个指针指向不同的内存地址。一般用来修饰NSString等有对应可变类型的对象，因为他们有可能和对应的可变类型（NSMutableString）之间进行赋值操作，为确保对象中的字符串不被修改 ，应该在设置属性是拷贝一份。而若用strong修饰，如果对象在外部被修改了，会影响到属性。</p>
<p>block属性为什么需要用copy来修饰？<br>因为在MRC下，block在创建的时候，它的内存是分配在栈(stack)上的，而不是在堆(heap)上，可能被随时回收。他本身的作于域是属于创建时候的作用域，一旦在创建时候的作用域外面调用block将导致程序崩溃。通过copy可以把block拷贝（copy）到堆，保证block的声明域外使用。在ARC下写不写都行，编译器会自动对block进行copy操作。<br><strong>block与</strong>weak的区别<br>•    <strong>block：在ARC和MRC下都可用，可修饰对象，也可以修饰基本数据类型。<br>•    </strong>block对象可以在block被重新赋值，<strong>weak不可以。<br>•    </strong>weak：只在ARC中使用，只能修饰对象，不能修饰基本数据类型（int、bool）。<br>•    同时，在ARC下，要避免block出现循环引用，经常会：<strong>weak typedof(self) weakSelf = self;</strong><br>5.<br> 6.<br>用[[UITableViewCell alloc]() initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier]创建10次cell，<br>并给cell指定同样的重用标识(当然，可以为不同显示类型的cell指定不同的标识)。<br>并且10个cell全部都加入到visiableCells数组，reusableTableCells为空。<br>向下拖动tableView，当cell1完全移出屏幕，并且cell11(它也是alloc出来的，原因同上)完全显示出来的时候。cell11加入到visiableCells，cell1移出visiableCells，cell1加入到reusableTableCells。<br> 接着向下拖动tableView，因为reusableTableCells中已经有值，所以，当需要显示新的cell，cellForRowAtIndexPath再次被调用的时候，tableView dequeueReusableCellWithIdentifier:CellIdentifier，返回cell1。cell1加入到visiableCells，cell1移出reusableTableCells；cell2移出visiableCells，cell2加入到reusableTableCells。之后再需要显示的Cell就可以正常重用了。</p>
<p>7.cocoa 中所有的类都是NSObject 的子类，多继承在这里是用protocol 委托代理来实现的。你不用去考虑繁琐的多继承，虚基类的概念。多态特性在 obj-c 中通过委托来实现。 </p>
<p>8.Protocol只是声明一套接口，并不能提供具体实现，变相的也算是一种抽象基类的实现方式（OC本身语法并不支持抽象基类）。<br>Category可以为已有的类提供额外的接口和具体的实现。<br>Protocol只能提供一套公用的接口声明，并不能提供具体实现，它的行为是，我只负责声明，而不管谁去实现，去如何实现。这样的话，我定义一套接口，可以使任意的类都用不同的方式去实现接口中的方法，就是为遵守了protocol的类提供了一些额外访问这个类的一些接口，像delegate和dataSource用protocol实现是最好的。<br>Category是对一个功能完备的类的一种补充、扩展，就像一个东西基本功能都完成了，可以用category为这个类添加不同的组件，使得这个类能够适应不同情况的需求（但是这些不同需求最核心的需求要一致）。当然，当某个类非常大的时候，使用category可以按照不同的功能将类的实现分在不同的模块中。还有，虽然category可以访问已有类的实例变量，但不能创建新的实例变量，如果要创建新的实例变量，请使用继承。<br>继承，它基于Protocol和Category之间，既可以像protocol一样只提供纯粹的接口，也可以像Category一样提供接口的完整实现，可以自由定义类的实例变量（这一点，Protocol倒是可以声明实例变量，但是也仅仅是声明而已），而且继承还可以对类以后的方法进行改写，所以继承的力量是最强大的。<br>在iOS开发中，继承是完全可以完成protocol和category的功能的，那么在开发过程中多多使用继承体系可好？<br>需要注意的是使用继承还有很大的代价问题。使用继承来进行扩展是一种耦合度很高的行为，对父类可以说是完全依赖，如果继承体系太过复杂，会造成难以维护的问题。如果仅仅只是对类进行扩展，并不建议使用继承，毕竟使用protocol和category是很简单、轻松的。除此之外，在开发过程中，我们应该尽量将界面、功能相似的类的代码提取到基类里面，然后各个子类继承自这个基类，实现各自的其他特殊部分。这样可以大大的优化代码，如果需要修改的话，只需要这倒对应子类修改即可。<br>category是可以被继承的。在某个父类中定义了category，那么他所有的子类都具有该category；<br>在需要为某个类创建私有成员方法时，也用category的方式来实现。<br>Category不能完全代替子类，有以下几个最大的缺点：<br>1.当在Category中覆盖一个继承的方法，在Category中的方法可以通过向super类发送一个消息来调用被继承的方法。但是，如果Category中覆盖的那个方法已经在这个类的其它Category定义过了，则之前定义的方法将没有机会被程序调用<br>2.在Category中无法确定其能够可靠的覆盖某个方法，而这个方法已经在其它的Category中定义过。这个问题在使用Cocoa框架时尤其 突出。当你想覆盖某个框架已经定义好的方法时，该方法已经在其它Category中实现，这样就无法确定哪个定义和实现会被最先使用，带来很大的不确定性。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基础：&lt;br&gt;1.&lt;br&gt;2.ios中实现callback可以通过两种方法，委托和NSNotification&lt;br&gt;委托的话是一对一的关系，例如一个UIViewController里有一个tableView, 将该viewController设置为tableView的委托
    
    </summary>
    
      <category term="IOS" scheme="http://www.jeyblogs.com/categories/IOS/"/>
    
    
      <category term="面试" scheme="http://www.jeyblogs.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>iOS面试题</title>
    <link href="http://www.jeyblogs.com/2016/10/23/iOS%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://www.jeyblogs.com/2016/10/23/iOS面试题/</id>
    <published>2016-10-23T13:36:19.000Z</published>
    <updated>2017-02-23T08:46:14.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>button 有个addTarget 事件，你能大概讲一下他内部大概是怎么实现的吗？<br>答：内部的一个消息监听，通过指针、响应函数地址实现方法调用</li>
<li>常见的object-c的数据类型有那些， 和C的基本数据类型有什么区别?如：NSInteger和int<br>答：object-c的数据类型有NSString，NSNumber，NSArray，NSMutableArray，NSData等等，这些都是class，创建后便是对象，而C语言的基本数据类型int，只是一定字节的内存空间，用于存放数值;NSInteger是基本数据类型，并不是NSNumber的子类，当然也不是NSObject的子类。NSInteger是基本数据类型Int或者Long的别名(NSInteger的定义typedef long NSInteger)，它的区别在于，NSInteger会根据系统是32位还是64位来决定是本身是int还是Long。</li>
<li>id 声明的对象有什么特性?<br>答：Id 声明的对象具有运行时的特性，即可以指向任意类型的objcetive-c的对象;</li>
<li>代理的作用?<br>答：代理的目的是改变或传递控制链。允许一个类在某些特定时刻通知到其他类，而不需要获取到那些类的指针。可以减少框架复杂度。<br>另外一点，代理可以理解为java中的回调监听机制的一种类似。</li>
<li><p>我们说的oc是动态运行时语言是什么意思?<br>答：多态。 主要是将数据类型的确定由编译时，推迟到了运行时。<br>这个问题其实浅涉及到两个概念，运行时和多态。<br>简单来说，运行时机制使我们直到运行时才去决定一个对象的类别，以及调用该类别对象指定方法。<br>多态：不同对象以自己的方式响应相同的消息的能力叫做多态。意思就是假设生物类(life)都用有一个相同的方法-eat;<br>那人类属于生物，猪也属于生物，都继承了life后，实现各自的eat，但是调用是我们只需调用各自的eat方法。<br>也就是不同的对象以自己的方式响应了相同的消息(响应了eat这个选择器)。<br>因此也可以说，运行时机制是多态的基础?</p>
</li>
<li><p>对于单例的理解<br>答：在objective-c中要实现一个单例类，至少需要做以下四个步骤：<br>1).为单例对象实现一个静态实例，并初始化，然后设置成nil，<br>2).实现一个实例构造方法检查上面声明的静态实例是否为nil，如果是则新建并返回一个本类的实例，<br>3).重写allocWithZone方法，用来保证其他人直接使用alloc和init试图获得一个新实力的时候不产生一个新实例，<br>4).适当实现allocWitheZone，copyWithZone，release和autorelease。</p>
</li>
<li>方法和选择器有何不同?<br>答：selector是一个方法的名字，method是一个组合体，包含了名字和实现.</li>
</ol>
<p>初级题目<br>1.在oc中如何实现深度拷贝<br>2.请描述什么是delegate、block、NSNotification，他们有什么作用<br>3.请写出一个线程安全的单例模式<br>4.解释属性中strong、weak、assign、copy的区别<br>5.#import和#include的区别<br>6.描述tableView的重用机制<br>7.Object-C有多继承吗？没有的话用什么代替？<br>8.category与继承之间的区别<br>9.#define和const定义的变量，有什么区别<br>10.TCP和UDP的区别是什么？<br>11.MD5和Base64的区别是什么，各自场景是什么？<br>12.二叉搜索树的概念，时间复杂度多少？<br>13.如何添加一个自定义字体到工程中<br>14.如何制作一个静态库/动态库，他们的区别是什么？<br>15.Configuration中，debug和release的区别是什么？<br>16.push view controller 和 present view controller的区别<br>17.描述下tableview cell的重用机制<br>18.UIView的frame和bounds的区别是什么<br>19.new与alloc init的区别<br>20.NSArray实例化时，array与init的区别</p>
<p>中级题目<br>1.什么是arc？（arc是为了解决什么问题诞生的？）<br>2.请解释以下keywords的区别： assign vs weak, <strong>block vs </strong>weak<br>3.__block在arc和非arc下含义一样吗？<br>4.使用atomic一定是线程安全的吗？  </p>
<ol>
<li>描述一个你遇到过的retain cycle例子。(别撒谎，你肯定遇到过)  </li>
<li>+(void)load; +(void)initialize；有什么用处？  </li>
<li>为什么其他语言里叫函数调用， objective c里则是给对象发消息（或者谈下对runtime的理解）  </li>
<li>什么是method swizzling?  </li>
<li>UIView和CALayer是啥关系？  </li>
<li>如何高性能的给UIImageView加个圆角？（不准说layer.cornerRadius!）  </li>
<li>使用drawRect有什么影响？（这个可深可浅，你至少得用过。。）  </li>
<li>ASIHttpRequest或者SDWebImage里面给UIImageView加载图片的逻辑是什么样的？（把UIImageView放到UITableViewCell里面问更赞）  </li>
<li>麻烦你设计个简单的图片内存缓存器（移除策略是一定要说的）  </li>
<li>讲讲你用Instrument优化动画性能的经历吧（别问我什么是Instrument）  </li>
<li>loadView是干嘛用的？  </li>
<li>viewWillLayoutSubView你总是知道的。。  </li>
<li>GCD里面有哪几种Queue？你自己建立过串行queue吗？背后的线程模型是什么样的？  </li>
<li>用过coredata或者sqlite吗？读写是分线程的吗？遇到过死锁没？咋解决的？  </li>
<li>http的post和get啥区别？（区别挺多的，麻烦多说点）  </li>
<li>我知道你大学毕业过后就没接触过算法数据结构了，但是请你一定告诉我什么是Binary search tree? search的时间复杂度是多少？我很想知道！<br>21.哪些类不适合使用单例模式？即使他们在周期中只会出现一次。<br>22.Notification的使用场景是什么？同步还是异步？<br>23.简单介绍一下KVC和KVO，他们都可以应用在哪些场景？<br>24.UIButton的父类是什么？UILabel呢？<br>25.发送10个网络请求，然后再接收到所有回应之后执行后续操作，如何实现？<br>26.实现一个第三方控件，可以在任何时候出现在APP界面最上层<br>27.不同版本的APP，数据库结构变化了，如何处理?<br>28.内存中的栈和堆的区别是什么？那些数据在栈上，哪些在堆上？<br>29.block中的weak self，是任何时候都需要加的么？<br>30.GCD的queue，main queue中执行的代码，一定是在main thread么？<br>31.NSOperationQueue有哪些使用方式<br>32.NSThread中的Runloop的作用，如何使用？<br>33..h文件中的变量，外部可以直接访问么？（注意是变量，不是property）<br>34.讲述一下runtime的概念，message send如果寻找不到相应的对象，会如何进行后续处理 ？<br>35.利用runtime实现一个对象的拷贝__</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;button 有个addTarget 事件，你能大概讲一下他内部大概是怎么实现的吗？&lt;br&gt;答：内部的一个消息监听，通过指针、响应函数地址实现方法调用&lt;/li&gt;
&lt;li&gt;常见的object-c的数据类型有那些， 和C的基本数据类型有什么区别?如：NSIntege
    
    </summary>
    
      <category term="IOS" scheme="http://www.jeyblogs.com/categories/IOS/"/>
    
    
      <category term="面试" scheme="http://www.jeyblogs.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>hexo——搭建Github Page博客(2)</title>
    <link href="http://www.jeyblogs.com/2016/08/16/hexo%E2%80%94%E2%80%94%E6%90%AD%E5%BB%BAGithub-Page%E5%8D%9A%E5%AE%A2(2)/"/>
    <id>http://www.jeyblogs.com/2016/08/16/hexo——搭建Github-Page博客(2)/</id>
    <published>2016-08-16T02:18:28.000Z</published>
    <updated>2016-09-23T02:29:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><em><strong>GitHub Pages是什么？</strong></em><br>GitHub Pages本用于介绍托管在GitHub的项目， 他的空间免费稳定，用来做搭建一个博客再好不过，还可以根据自己的风格定制主题。<br><strong>1.github上建立仓库</strong><br>登录后系统，在github首页，点击页面右下角「New Repository<br><em>project name：jeyblogs.github.io</em><br><em>description： Writing 1000 Words a Day Changed My Life</em><br>注：Github Pages的Repository名字跟Github账号是一致的，比如我的Github账号是jeyblogs，Github Pages Repository名字就是jeyblogs.github.io。<br><strong>2.在setting的Github Pages模块激活</strong><br><strong>3.把Github Page站点下载到本地</strong><br><code>git clone [https://github.com/jeyblogs/jeyblogs.github.io.git]</code><br><strong>4.生成hero</strong><br>cd /站点本地仓库文件夹<br>hexo init<br><strong>5.申请独立域名，Godaddy注册并购买域名，我的jeyblogs.com，指向Github pages</strong><br><strong>6.在Github Pages站点目录下新建文件CNAME，里面文本是你的域名，jeyblogs.com</strong><br><strong>7.在github仓库中创建一个分支gh-pages</strong></p>
<p><em>进阶篇：Hexo设置</em><br>网站搭建完成后，就可以根据自己爱好来对Hexo生成的网站进行设置了，对整站的设置，只要修改项目目录的<em>config.yml就可以了</em> </p>
<pre><code>Extensions
Plugins: https://hexo.io/plugins/
Themes: https://hexo.io/themes/
theme: hexo-next
Deployment
Docs: https://hexo.io/docs/deployment.htm


deploy:
type: git
repository: git@github.com:jeyblogs/jeyblogs.github.io.git
branch: master
</code></pre><p><strong>用Hexo发表文章的Markdown语法</strong><br>使用jacman或pacman主题，建议按此标准语法写：</p>
<pre><code>title: postName #文章页面上的显示名称，可以任意修改，不会出现在URL中
date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改
category: example #分类
tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格
description: 附加一段文章摘要，字数最好在140字以内。
---
</code></pre><p><strong>Hexo命令</strong><br>常用命令：</p>
<pre><code>hexo new &quot;postName&quot; #新建文章
hexo new page &quot;pageName&quot; #新建页面
hexo generate #生成静态页面至public目录
hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）
hexo deploy #将.deploy目录部署到GitHub
</code></pre><p>常用复合命令：</p>
<pre><code>hexo d -g #生成加部署
hexo s -g #预览加部署
</code></pre><p>简写：</p>
<pre><code>hexo n == hexo new
hexo g == hexo generate
hexo s == hexo server
hexo d == hexo deploy
</code></pre><p>安装插件<br>添加sitemap和feed插件</p>
<pre><code>$ npm install hexo-generator-sitemap
$ npm install hexo-generator-feed
</code></pre><p><em>注：</em><br>站点本地仓库文件夹目录下source是自己在本地的文件，新建的page和文章都在，hexo g命令后会自动生成public文件夹，生成的网页，文章里面的categories也是在source中，新建的page，categories是跟posts文件夹同级的，themes是主题目录</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;&lt;strong&gt;GitHub Pages是什么？&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;GitHub Pages本用于介绍托管在GitHub的项目， 他的空间免费稳定，用来做搭建一个博客再好不过，还可以根据自己的风格定制主题。&lt;br&gt;&lt;strong&gt;1.github上建
    
    </summary>
    
      <category term="Hexo" scheme="http://www.jeyblogs.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://www.jeyblogs.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo——搭建Github Page博客之配置篇(1)</title>
    <link href="http://www.jeyblogs.com/2016/08/15/hexo%E2%80%94%E2%80%94%E6%90%AD%E5%BB%BAGithub%20Page%E5%8D%9A%E5%AE%A2(1)/"/>
    <id>http://www.jeyblogs.com/2016/08/15/hexo——搭建Github Page博客(1)/</id>
    <published>2016-08-15T02:29:49.000Z</published>
    <updated>2016-08-17T15:37:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>hero是一款轻量级的博客系统，它能够定制属于自己的个性化主题博客。<br><strong>Hexo环境配置</strong><br>先屡一下思路<br>1.首先hexo是基于nodejs的，所以必须安装nodejs<br>2.安装nodejs方法很多，我选择homebrew安装方式，所以需要安装它<br>3.安装homebrew就很简单了，mac自带ruby脚本功能，一句话搞定<br>4.hexo提交部署github需要使用git工具，所以需要安装git，用homebrew的话也是一句话搞定（mac也有自带）<br>5.OK整理一下安装顺序：homebrew-nodejs-hexo-git</p>
<h5 id="安装brewhome，一句话搞定"><a href="#安装brewhome，一句话搞定" class="headerlink" title="安装brewhome，一句话搞定"></a>安装brewhome，一句话搞定</h5><pre><code>ruby -e &quot;$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)”
</code></pre><h5 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h5><h6 id="第一种方式，brewhome安装，一句话搞定"><a href="#第一种方式，brewhome安装，一句话搞定" class="headerlink" title="第一种方式，brewhome安装，一句话搞定"></a>第一种方式，brewhome安装，一句话搞定</h6><pre><code>brew install node
</code></pre><h6 id="第二种方式，前提是已经安装好Xcode和git"><a href="#第二种方式，前提是已经安装好Xcode和git" class="headerlink" title="第二种方式，前提是已经安装好Xcode和git"></a>第二种方式，前提是已经安装好Xcode和git</h6><pre><code>git clone git://github.com/joyent/node.git
cd node
./configure
make
sudo make install
</code></pre><h5 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h5><h6 id="第一种方式，用nodejs自带npm安装"><a href="#第一种方式，用nodejs自带npm安装" class="headerlink" title="第一种方式，用nodejs自带npm安装"></a>第一种方式，用nodejs自带npm安装</h6><pre><code>npm install -g hexo
hexo init
npm install
</code></pre><h6 id="第二种方式，下载源码-http-www-nodejs-org-download-，编译执行"><a href="#第二种方式，下载源码-http-www-nodejs-org-download-，编译执行" class="headerlink" title="第二种方式，下载源码(http://www.nodejs.org/download/)，编译执行"></a>第二种方式，下载源码(<a href="http://www.nodejs.org/download/)，编译执行" target="_blank" rel="external">http://www.nodejs.org/download/)，编译执行</a></h6><pre><code>./configure --prefix=~/nodejs &amp;&amp; make &amp;&amp; make install
cp ~/nodejs/bin/node /usr/sbin/node
~/nodejs/bin/npm install -g hexo
</code></pre><h5 id="安装git（mac一般自带）"><a href="#安装git（mac一般自带）" class="headerlink" title="安装git（mac一般自带）"></a>安装git（mac一般自带）</h5><pre><code>sudo brew install git
</code></pre><h5 id="SSH-key"><a href="#SSH-key" class="headerlink" title="SSH key"></a>SSH key</h5><h6 id="检查SSH-key"><a href="#检查SSH-key" class="headerlink" title="检查SSH key"></a>检查SSH key</h6><pre><code>cd ~/.ssh
</code></pre><h6 id="备份已有的key，（如果有的话）"><a href="#备份已有的key，（如果有的话）" class="headerlink" title="备份已有的key，（如果有的话）"></a>备份已有的key，（如果有的话）</h6><pre><code>mkdir key_backup
mv id_rsa* key_backup
</code></pre><h6 id="生成SSH-key"><a href="#生成SSH-key" class="headerlink" title="生成SSH key"></a>生成SSH key</h6><pre><code>ssh-keygen -t rsa -C &quot;xxx@xxx.com”
</code></pre><h6 id="将SSH-key添加到Github"><a href="#将SSH-key添加到Github" class="headerlink" title="将SSH key添加到Github"></a>将SSH key添加到Github</h6><p>登录到GitHub页面，Account Settings->deploy Keys->Add another key将生成的key(id_rsa.pub文件）内容copy到输入框中，save。_</p>
<h6 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h6><pre><code>ssh git@github.com
</code></pre><h6 id="设置个人信息"><a href="#设置个人信息" class="headerlink" title="设置个人信息"></a>设置个人信息</h6><pre><code>git config --global user.name &quot;xxx”
git config --global user.email xxx@xxx.com
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hero是一款轻量级的博客系统，它能够定制属于自己的个性化主题博客。&lt;br&gt;&lt;strong&gt;Hexo环境配置&lt;/strong&gt;&lt;br&gt;先屡一下思路&lt;br&gt;1.首先hexo是基于nodejs的，所以必须安装nodejs&lt;br&gt;2.安装nodejs方法很多，我选择homebre
    
    </summary>
    
      <category term="Hexo" scheme="http://www.jeyblogs.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://www.jeyblogs.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>iOS运行证书报错问题整理</title>
    <link href="http://www.jeyblogs.com/2016/03/27/iOS%E8%BF%90%E8%A1%8C%E8%AF%81%E4%B9%A6%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <id>http://www.jeyblogs.com/2016/03/27/iOS运行证书报错问题整理/</id>
    <published>2016-03-27T02:36:28.000Z</published>
    <updated>2016-09-27T03:16:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名iOS工程师，在开发中遇到各种证书报错的问题，在这里，我就把多年的实践经验分享出来，希望能够对大家有所帮助：</p>
<ol>
<li><p>iPhone上已经装了Bundle ID一样的 App，删掉再运行。</p>
<p> This application’s application-identifier entitlement does not match that of the installed application. These values must match for an upgrade to be allowed.</p>
</li>
<li><p>还是描述文件的问题，把发布的描述文件或者是 hoc 的描述文件当成开发描述文件使用了。</p>
<p> process launch failed: timed out trying to launch app</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一名iOS工程师，在开发中遇到各种证书报错的问题，在这里，我就把多年的实践经验分享出来，希望能够对大家有所帮助：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;iPhone上已经装了Bundle ID一样的 App，删掉再运行。&lt;/p&gt;
&lt;p&gt; This application’s 
    
    </summary>
    
      <category term="Developer" scheme="http://www.jeyblogs.com/categories/Developer/"/>
    
    
      <category term="Xcode" scheme="http://www.jeyblogs.com/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>Xcode通过Jenkins自动打包ipa</title>
    <link href="http://www.jeyblogs.com/2015/11/25/Xcode%E9%80%9A%E8%BF%87Jenkins%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85ipa/"/>
    <id>http://www.jeyblogs.com/2015/11/25/Xcode通过Jenkins自动打包ipa/</id>
    <published>2015-11-25T08:40:19.000Z</published>
    <updated>2016-08-31T09:49:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Jenkins自动打包ipa"><a href="#Jenkins自动打包ipa" class="headerlink" title="Jenkins自动打包ipa"></a>Jenkins自动打包ipa</h3><p>如果Mac 上没有安装brew。先安装：ruby -e “$(curl -fsSL <a href="https://raw.github.com/Homebrew/homebrew/go/install" target="_blank" rel="external">https://raw.github.com/Homebrew/homebrew/go/install</a>)”<br>首先安装jenkins #: brew install jenkins        brew 官网：<a href="http://brew.sh" target="_blank" rel="external">http://brew.sh</a>   或直接从Jenkins下载：<a href="http://jenkins-ci.org" target="_blank" rel="external">http://jenkins-ci.org</a></p>
<p>安装完成后浏览器打开：<a href="http://localhost:8080" target="_blank" rel="external">http://localhost:8080</a>   Jenkins 默认地址<br>首先请确认本地的xcode 工程是否能生成ipa 最好先试一次。如果xcode 能正常生成ipa 那么下面的才能实现</p>
<h4 id="坑：增加Xcode插件（失败了的话找找插件）"><a href="#坑：增加Xcode插件（失败了的话找找插件）" class="headerlink" title="坑：增加Xcode插件（失败了的话找找插件）"></a>坑：增加Xcode插件（失败了的话找找插件）</h4><p>在jenkins的系统管理中，找到管理插件，可选插件的tab下搜索xcode，勾选安装，安装插件/升级处等待?jenkins升级到最新版本了，xcode插件更好安装（如果失败请下载最新的jenkjins，或者多尝试几次）。<br>这样重启jenkins的话，就会在job的构建中下拉选择处看到xcode的支持选项。</p>
<p>1.新建一个自由风格的项目<br>2.第一步<img src="http://7xsdar.com1.z0.glb.clouddn.com/jenkins1.png" alt=""><br>3.从SVN地址拉取源码<img src="http://7xsdar.com1.z0.glb.clouddn.com/jenkins2.png" alt=""><br>4.设置自动打包时间<img src="http://7xsdar.com1.z0.glb.clouddn.com/jenkins3.png" alt=""><br>5.<img src="http://7xsdar.com1.z0.glb.clouddn.com/jenkins4.png" alt=""><br>1.cd jenkins拉取的项目在本地的路径 xcodebuild -archivePath “enkins拉取的项目在本地的路径/项目名称.xcarchive” -sdk iphoneos -scheme “Jueee” -configuration “Release” archive<br>    例：cd /Users/package/.jenkins/jobs/Ueee/workspace xcodebuild -archivePath “/Users/package/.jenkins/jobs/Ueee/workspace/Jueee.xcarchive” -sdk iphoneos -scheme “Jueee” -configuration “Release” archive</p>
<p>2.设置打包至桌面page<br>    xcodebuild -exportArchive -exportFormat IPA -archivePath “/Users/package/.jenkins/jobs/Ueee/workspace/Jueee.xcarchive” -exportPath “/Users/package/Desktop/page/Jueee$(date +%Y%m%d%H%M).ipa”</p>
<p>3.上传至fir命令<br>    fir publish /Users/package/Desktop/page/Jueee$(date +%Y%m%d%H%M).ipa -T e9032bee861fcf8ea623e8cb2090e40c</p>
<p><strong>或者：</strong><br>第五步的Execute shell下的command可以改为一个命令：<br>    fir build_ipa /Users/package/.jenkins/jobs/Ueee/workspace/Jueee.xcodeproj -o /Users/package/Desktop/page/ -n Jueee$(date +%Y%m%d%H) -p -c “update” -Q -T e9032bee861fcf8ea623e8cb2090e40c</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Jenkins自动打包ipa&quot;&gt;&lt;a href=&quot;#Jenkins自动打包ipa&quot; class=&quot;headerlink&quot; title=&quot;Jenkins自动打包ipa&quot;&gt;&lt;/a&gt;Jenkins自动打包ipa&lt;/h3&gt;&lt;p&gt;如果Mac 上没有安装brew。先安装：ru
    
    </summary>
    
      <category term="工具" scheme="http://www.jeyblogs.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Xcode" scheme="http://www.jeyblogs.com/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>GCD Dispatch</title>
    <link href="http://www.jeyblogs.com/2015/11/15/GCD%20Dispatch/"/>
    <id>http://www.jeyblogs.com/2015/11/15/GCD Dispatch/</id>
    <published>2015-11-15T02:29:49.000Z</published>
    <updated>2016-08-30T10:16:51.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="设计："><a href="#设计：" class="headerlink" title="设计："></a>设计：</h4><p>GCD的工作原理是：让程序平行排队的特定任务，根据可用的处理资源，安排他们在任何可用的处理器核心上执行任务。<br>一个任务可以是一个函数(function)或者是一个block。 GCD的底层依然是用线程实现，不过这样可以让程序员不用关注实现的细节。<br>GCD中的FIFO队列称为dispatch queue，它可以保证先进来的任务先得到执行<br>dispatch queue分为下面三种：</p>
<h4 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h4><p>又称为private dispatch queues，同时只执行一个任务。Serial queue通常用于同步访问特定的资源或数据。当你创建多个Serial queue时，虽然它们各自是同步执行的，但Serial queue与Serial queue之间是并发执行的。</p>
<h4 id="Concurrent"><a href="#Concurrent" class="headerlink" title="Concurrent"></a>Concurrent</h4><p>又称为global dispatch queue，可以并发地执行多个任务，但是执行完成的顺序是随机的。</p>
<h4 id="Main-dispatch-queue"><a href="#Main-dispatch-queue" class="headerlink" title="Main dispatch queue"></a>Main dispatch queue</h4><p>它是全局可用的serial queue，它是在应用程序主线程上执行任务的。</p>
<p>1、dispatch_group_async的使用<br>dispatch_group_async可以实现监听一组任务是否完成，完成后得到通知执行其他的操作。这个方法很有用，比如你执行三个下载任务，当三个任务都下载完成后你才通知界面说完成的了。下面是一段例子代码：</p>
<p>1   dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);<br>2   dispatch_group_t group = dispatch_group_create();<br>3   dispatch_group_async(group, queue, ^<br>4       <a href="#">NSThread sleepForTimeInterval:1</a>;<br>5       NSLog(@”group1”);<br>6   });<br>7   dispatch_group_async(group, queue, ^<br>8       <a href="#">NSThread sleepForTimeInterval:2</a>;<br>9       NSLog(@”group2”);<br>10  });<br>11  dispatch_group_async(group, queue, ^<br>12      <a href="#">NSThread sleepForTimeInterval:3</a>;<br>13      NSLog(@”group3”);<br>14  });<br>15  dispatch_group_notify(group, dispatch_get_main_queue(), ^<br>16      NSLog(@”updateUi”);<br>17  });<br>18  dispatch_release(group);<br>dispatch_group_async是异步的方法，运行后可以看到打印结果：</p>
<p>2012-09-25 16:04:16.737 gcdTest<a href="#">43328:11303</a> group1<br>2012-09-25 16:04:17.738 gcdTest<a href="#">43328:12a1b</a> group2<br>2012-09-25 16:04:18.738 gcdTest<a href="#">43328:13003</a> group3<br>2012-09-25 16:04:18.739 gcdTest<a href="#">43328:f803</a> updateUi<br>每个一秒打印一个，当第三个任务执行后，upadteUi被打印。</p>
<p>2、dispatch_barrier_async的使用<br>dispatch_barrier_async是在前面的任务执行结束后它才执行，而且它后面的任务等它执行完成之后才会执行<br>例子代码如下：</p>
<p>1   dispatch_queue_t queue = dispatch_queue_create(“gcdtest.rongfzh.yc”, DISPATCH_QUEUE_CONCURRENT);<br>2   dispatch_async(queue, ^<br>3       <a href="#">NSThread sleepForTimeInterval:2</a>;<br>4       NSLog(@”dispatch_async1”);<br>5   });<br>6   dispatch_async(queue, ^<br>7       <a href="#">NSThread sleepForTimeInterval:4</a>;<br>8       NSLog(@”dispatch_async2”);<br>9   });<br>10  dispatch_barrier_async(queue, ^<br>11      NSLog(@”dispatch_barrier_async”);<br>12      <a href="#">NSThread sleepForTimeInterval:4</a>;<br>13<br>14  });<br>15  dispatch_async(queue, ^<br>16      <a href="#">NSThread sleepForTimeInterval:1</a>;<br>17      NSLog(@”dispatch_async3”);<br>18  });  </p>
<p>打印结果：</p>
<p>2012-09-25 16:20:33.967 gcdTest<a href="#">45547:11203</a> dispatch_async1<br>2012-09-25 16:20:35.967 gcdTest<a href="#">45547:11303</a> dispatch_async2<br>2012-09-25 16:20:35.967 gcdTest<a href="#">45547:11303</a> dispatch_barrier_async<br>2012-09-25 16:20:40.970 gcdTest<a href="#">45547:11303</a> dispatch_async3<br>请注意执行的时间，可以看到执行的顺序如上所述。<br>3、dispatch_apply<br>执行某个代码片段N次。<br>dispatch_apply(5, globalQ, ^(size_t index)<br>    // 执行5次<br>});</p>
<h5 id="这段代码逐步演示了如何修正错误，其中用到的既是串行队列"><a href="#这段代码逐步演示了如何修正错误，其中用到的既是串行队列" class="headerlink" title="这段代码逐步演示了如何修正错误，其中用到的既是串行队列"></a>这段代码逐步演示了如何修正错误，其中用到的既是串行队列</h5><p>1。这个是原始代码<br>view plain</p>
<ul>
<li>(void)viewWillAppear:(BOOL)animated  </li>
</ul>
<pre><code>NSData \*imageData = [FlickrFetcher imageDataForPhotoWithURLString:photo.URL][16];  
UIImage \*image = [UIImage imageWithData:imageData][17];  
self.imageView.image = image;  
self.imageView.frame = CGRectMake(0, 0, image.size.width, image.size.height);  
self.scrollView.contentSize = image.size;  
</code></pre><p>}  </p>
<p>2。这个是采用gcdd的代码，里面有错误3处<br>view plain</p>
<ul>
<li><p>(void)viewWillAppear:(BOOL)animated  </p>
<p>  dispatch_queue_t downloadQueue = dispatch_queue_create(“Flickr downloader”, NULL);<br>  dispatch_async(downloadQueue, ^  </p>
<pre><code>NSData \*imageData = [FlickrFetcher imageDataForPhotoWithURLString:photo.URL][18];  
UIImage \*image = [UIImage imageWithData:imageData][19];  
self.imageView.image = image;  
self.imageView.frame = CGRectMake(0, 0, image.size.width, image.size.height);  
self.scrollView.contentSize = image.size;  
</code></pre><p>  });<br>}  </p>
</li>
</ul>
<p>3。第一个错误，UI更新只能在主线程中 Problem! UIKit calls can only happen in the main thread!<br>改正后如下：<br>view plain</p>
<ul>
<li><p>(void)viewWillAppear:(BOOL)animated  </p>
<p>  dispatch_queue_t downloadQueue = dispatch_queue_create(“Flickr downloader”, NULL);<br>  dispatch_async(downloadQueue, ^  </p>
<pre><code> NSData \*imageData = [FlickrFetcher imageDataForPhotoWithURLString:photo.URL][20];  
dispatch\_async(dispatch\_get\_main\_queue(), ^
     UIImage \*image = [UIImage imageWithData:imageData][21];  
     self.imageView.image = image;  
     self.imageView.frame = CGRectMake(0, 0, image.size.width, image.size.height);  
     self.scrollView.contentSize = image.size;  
 });  
</code></pre><p>}); }  </p>
</li>
</ul>
<p>4。第二个错误，NSManagedObjectContext并不是线程安全的，gcd中访问成员变量有危险<br>Problem! NSManagedObjectContext is not thread safe,<br>so we can’t call photo.URL in downloadQueue’s t<br>改正后如下：<br>view plain</p>
<ul>
<li><p>(void)viewWillAppear:(BOOL)animated  </p>
<p>NSString *url = photo.URL;<br>  dispatch_queue_t downloadQueue = dispatch_queue_create(“Flickr downloader”, NULL);<br>  dispatch_async(downloadQueue, ^  </p>
<pre><code>NSData \*imageData = [FlickrFetcher imageDataForPhotoWithURLString:url][22]; 
dispatch\_async(dispatch\_get\_main\_queue(), ^  
    UIImage \*image = [UIImage imageWithData:imageData][23];  
    self.imageView.image = image;  
    self.imageView.frame = CGRectMake(0, 0, image.size.width, image.size.height);  
    self.scrollView.contentSize = image.size;  
</code></pre><p>});<br>});<br>}<br>5。第三个错误，队列创建后没有释放，内存泄露<br>view plain</p>
</li>
<li><p>(void)viewWillAppear:(BOOL)animated  </p>
<p>  NSString *url = photo.URL;<br>  dispatch_queue_t downloadQueue = dispatch_queue_create(“Flickr downloader”, NULL);<br>  dispatch_async(downloadQueue, ^  </p>
<pre><code>NSData \*imageData = [FlickrFetcher imageDataForPhotoWithURLString:url][24];  
dispatch\_async(dispatch\_get\_main\_queue(), ^  
    UIImage \*image = [UIImage imageWithData:imageData][25];  
    self.imageView.image = image;  
    self.imageView.frame = CGRectMake(0, 0, image.size.width, image.size.height);  
    self.scrollView.contentSize = image.size;  
</code></pre><p>});<br>});  </p>
</li>
</ul>
<p>dispatch_release(downloadQueue);<br> //won’t actually go away until queue is empty</p>
<p>}</p>
<h4 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h4><p>dispatch队列的生成可以有这几种方式：</p>
<ol>
<li>dispatch_queue_t queue = dispatch_queue_create(“com.dispatch.serial”, DISPATCH_QUEUE_SERIAL); //生成一个串行队列，队列中的block按照先进先出（FIFO）的顺序去执行，实际上为单线程执行。第一个参数是队列的名称，在调试程序时会非常有用，所有尽量不要重名了。</li>
<li>dispatch_queue_t queue = dispatch_queue_create(“com.dispatch.concurrent”, DISPATCH_QUEUE_CONCURRENT); //生成一个并发执行队列，block被分发到多个线程去执行</li>
<li>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //获得程序进程缺省产生的并发队列，可设定优先级来选择高、中、低三个优先级队列。由于是系统默认生成的，所以无法调用dispatch_resume()和dispatch_suspend()来控制执行继续或中断。需要注意的是，三个队列不代表三个线程，可能会有更多的线程。并发队列可以根据实际情况来自动产生合理的线程数，也可理解为dispatch队列实现了一个线程池的管理，对于程序逻辑是透明的。<br>官网文档解释说共有三个并发队列，但实际还有一个更低优先级的队列，设置优先级为DISPATCH_QUEUE_PRIORITY_BACKGROUND。Xcode调试时可以观察到正在使用的各个dispatch队列。</li>
<li>dispatch_queue_t queue = dispatch_get_main_queue(); //获得主线程的dispatch队列，实际是一个串行队列。同样无法控制主线程dispatch队列的执行继续或中断。<br>接下来我们可以使用dispatch_async或dispatch_sync函数来加载需要运行的block。<br>dispatch_async(queue, ^<br>　　//block具体代码<br>}); //异步执行block，函数立即返回<br>dispatch_sync(queue, ^<br>　　//block具体代码<br>}); //同步执行block，函数不返回，一直等到block执行完毕。编译器会根据实际情况优化代码，所以有时候你会发现block其实还在当前线程上执行，并没用产生新线程。<br>实际编程经验告诉我们，尽可能避免使用dispatch_sync，嵌套使用时还容易引起程序死锁。<br>如果queue1是一个串行队列的话，这段代码立即产生死锁：<br>dispatch_sync(queue1, ^<br>   dispatch_sync(queue1, ^<br>　　　　……<br>　　});<br>　　……<br>　});<br>不妨思考下，为什么下面代码也肯定死锁：<br>dispatch_sync(dispatch_get_main_queue(), ^<br>　　……<br>});<br>原因：1主线程通过dispatch_sync把block交给主队列后，会等待block里的任务结束再往下走自身的任务，<br>　　2.而队列是先进先出的，block里的任务也在等待主队列当中排在它之前的任务都执行完了再走自己。<br>　　这种循环等待就形成了死锁。所以在主线程当中使用dispatch_sync将任务加到主队列是不可取的。_<br>那实际运用中，一般可以用dispatch这样来写，常见的网络请求数据多线程执行模型：<br>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^<br>　　//子线程中开始网络请求数据<br>　　//更新数据模型<br>　　dispatch_sync(dispatch_get_main_queue(), ^<br>　　　　//在主线程中更新UI代码<br>　　});<br>});<br>程序的后台运行和UI更新代码紧凑，代码逻辑一目了然。</li>
</ol>
<p>dispatch队列是线程安全的，可以利用串行队列实现锁的功能。比如多线程写同一数据库，需要保持写入的顺序和每次写入的完整性，简单地利用串行队列即可实现：<br>dispatch_queue_t queue1 = dispatch_queue_create(“com.dispatch.writedb”, DISPATCH_QUEUE_SERIAL);</p>
<ul>
<li>(void)writeDB:(NSData *)data</li>
</ul>
<p>　　dispatch_async(queue1, ^<br>　　　　//write database<br>　　});<br>}<br>下一次调用writeDB:必须等到上次调用完成后才能进行，保证writeDB:方法是线程安全的。 </p>
<p>dispatch队列还实现其它一些常用函数，包括：<br>void dispatch_apply(size_t iterations, dispatch_queue_t queue, void (^block)(size_t)); //重复执行block，需要注意的是这个方法是同步返回，也就是说等到所有block执行完毕才返回，如需异步返回则嵌套在dispatch_async中来使用。多个block的运行是否并发或串行执行也依赖queue的是否并发或串行。<br>void dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block); //这个函数可以设置同步执行的block，它会等到在它加入队列之前的block执行完毕后，才开始执行。在它之后加入队列的block，则等到这个block执行完毕后才开始执行。<br>void dispatch_barrier_sync(dispatch_queue_t queue, dispatch_block_t block); //同上，除了它是同步返回函数<br>void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block); //延迟执行block<br>最后再来看看dispatch队列的一个很有特色的函数：<br>void dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t queue);<br>它会把需要执行的任务对象指定到不同的队列中去处理，这个任务对象可以是dispatch队列，也可以是dispatch源（以后博文会介绍）。而且这个过程可以是动态的，可以实现队列的动态调度管理等等。比如说有两个队列dispatchA和dispatchB，这时把dispatchA指派到dispatchB：<br>dispatch_set_target_queue(dispatchA, dispatchB);<br>那么dispatchA上还未运行的block会在dispatchB上运行。这时如果暂停dispatchA运行：<br>dispatch_suspend(dispatchA);<br>则只会暂停dispatchA上原来的block的执行，dispatchB的block则不受影响。而如果暂停dispatchB的运行，则会暂停dispatchA的运行。<br>这里只简单举个例子，说明dispatch队列运行的灵活性，在实际应用中你会逐步发掘出它的潜力。<br>dispatch队列不支持cancel（取消），没有实现dispatch_cancel()函数，不像NSOperationQueue，不得不说这是个小小的缺憾。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;设计：&quot;&gt;&lt;a href=&quot;#设计：&quot; class=&quot;headerlink&quot; title=&quot;设计：&quot;&gt;&lt;/a&gt;设计：&lt;/h4&gt;&lt;p&gt;GCD的工作原理是：让程序平行排队的特定任务，根据可用的处理资源，安排他们在任何可用的处理器核心上执行任务。&lt;br&gt;一个任务可以是一
    
    </summary>
    
      <category term="Developer" scheme="http://www.jeyblogs.com/categories/Developer/"/>
    
    
      <category term="GCD Dispatch" scheme="http://www.jeyblogs.com/tags/GCD-Dispatch/"/>
    
  </entry>
  
  <entry>
    <title>CocoaPods安装和使用</title>
    <link href="http://www.jeyblogs.com/2015/10/23/CocoaPods%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.jeyblogs.com/2015/10/23/CocoaPods安装和使用/</id>
    <published>2015-10-23T06:57:35.000Z</published>
    <updated>2016-08-30T09:59:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>CocoaPods是iOS最常用的第三方类库管理工具，绝大部分有名的开源类库都支持CocoaPods。</p>
<h5 id="CocoaPods安装"><a href="#CocoaPods安装" class="headerlink" title="CocoaPods安装"></a>CocoaPods安装</h5><p>步骤参考：<a href="http://www.cnblogs.com/wayne23/p/3912882.html" target="_blank" rel="external">http://www.cnblogs.com/wayne23/p/3912882.html</a></p>
<h5 id="CocoaPods使用"><a href="#CocoaPods使用" class="headerlink" title="CocoaPods使用"></a>CocoaPods使用</h5><ol>
<li>安装完成后cd 项目路径 </li>
<li>pod init生成podfile文件，在项目路径下</li>
<li>编辑pod init</li>
<li>寻找第三方类库的方法，pod search 类库名字，然后复制到podfile</li>
<li>最后在项目目录下pod update</li>
</ol>
<p>最近使用CocoaPods来添加第三方类库，无论是执行pod install还是pod update都卡在了Analyzing dependencies不动<br>原因在于当执行以上两个命令的时候会升级CocoaPods的spec仓库，加一个参数可以省略这一步，然后速度就会提升不少。加参数的命令如下：<br>pod install –verbose –no-repo-update<br>pod update –verbose –no-repo-update</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CocoaPods是iOS最常用的第三方类库管理工具，绝大部分有名的开源类库都支持CocoaPods。&lt;/p&gt;
&lt;h5 id=&quot;CocoaPods安装&quot;&gt;&lt;a href=&quot;#CocoaPods安装&quot; class=&quot;headerlink&quot; title=&quot;CocoaPods安装
    
    </summary>
    
      <category term="工具" scheme="http://www.jeyblogs.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="CocoaPods" scheme="http://www.jeyblogs.com/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>使用Alcatraz来管理Xcode插件</title>
    <link href="http://www.jeyblogs.com/2015/10/12/%E4%BD%BF%E7%94%A8Alcatraz%E6%9D%A5%E7%AE%A1%E7%90%86Xcode%E6%8F%92%E4%BB%B6/"/>
    <id>http://www.jeyblogs.com/2015/10/12/使用Alcatraz来管理Xcode插件/</id>
    <published>2015-10-12T08:06:36.000Z</published>
    <updated>2016-09-22T08:39:49.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xsdar.com1.z0.glb.clouddn.com/Alcatraz.png" alt="" title="img"></p>
<h5 id="￼简介"><a href="#￼简介" class="headerlink" title="￼简介"></a>￼简介</h5><p>Alcatraz 是一个帮你管理 Xcode 插件、模版以及颜色配置的工具。它可以直接集成到 Xcode 的图形界面中，让你感觉就像在使用 Xcode 自带的功能一样。</p>
<h5 id="安装和删除"><a href="#安装和删除" class="headerlink" title="安装和删除"></a>安装和删除</h5><p>第一步：关闭 Xcode。<br>第二步：如果你之前安装过Alcatraz，卸载它。运行命令：</p>
<pre><code>rm -rf  ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin~
</code></pre><p>第三步：最关键的一步，运行命令：</p>
<pre><code>find  ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins -name Info.plist -maxdepth 3 | xargs -I{} defaults write {} DVTPlugInCompatibilityUUIDs -array-add defaults read /Applications/Xcode.app/Contents/Info DVTPlugInCompatibilityUUID

sudo xcode-select --reset
</code></pre><p>第四步：安装 Alcatraz。</p>
<pre><code>curl -fsSL https://raw.github.com/supermarin/Alcatraz/master/Scripts/install.sh | sh
</code></pre><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>安装成功后重启 Xcode，选择load bundle,就可以在 Xcode 的顶部菜单中找到 Alcatraz，如下所示：<img src="http://7xsdar.com1.z0.glb.clouddn.com/Alcatraz-1.png" alt=""><br>￼<br>点击 “Package Manager”，即可启动插件列表页面，如下所示：<br>￼<img src="http://7xsdar.com1.z0.glb.clouddn.com/Alcatraz-2.png" alt=""><br>之后你可以在右上角搜索插件，对于想安装的插件，点击其左边的图标，即可下载安装，如下所示，我正在安装KImageNamed插件：<br>￼<img src="http://7xsdar.com1.z0.glb.clouddn.com/Alcatraz-3.png" alt=""><br>安装完成后，再次点击插件左边的图标，可以将该插件删除。</p>
<h5 id="插件路径"><a href="#插件路径" class="headerlink" title="插件路径"></a>插件路径</h5><p>Xcode 所有的插件都安装在目录/Library/Application Support/Developer/Shared/Xcode/Plug-ins/下，你也可以手工切换到这个目录来删除插件。</p>
<h5 id="推荐的插件"><a href="#推荐的插件" class="headerlink" title="推荐的插件"></a>推荐的插件</h5><p>几乎所有开发者都知道Alcatraz是一个开源的包管理工具，可以让我们更轻松地管理各种插件。接下来就介绍下我的最推荐的10个插件：<br>10.HOStringSense<br>在编辑字符串的时候，它会在代码上方生成一个字数统计的提示框。当你需要编辑多行文本时，可以在弹出的文本框中编辑字符串内容，插件会自动进行字符转义的工作，并实时在代码中更新。<br>￼<br>10.Peckham<br>可以在任何位置快速的import，快捷键为control+command+P  .这样写import语句就非常的方便。</p>
<p>9.OMColorSense<br>一个简洁的可视化颜色插件。在你编辑颜色的RGB值的时候，会在代码上方出现一个小的色块，显示对应的颜色。点击色块还会弹出一个颜色编辑器，在编辑器中得到的色值会自动填入colorWithRed:green:blue:alpha:方法中，贴心！<br>￼<br>8.Derived Data Exterminator<br>当你在编译项目的时候，是否曾为Xcode爆出的某个奇怪的错误绞尽脑汁？我想答案是肯定的，并且我们都明白，其中的一种错误的解决办法就是—删除DerivedData!尽管我们有很多种方法解决这个问题，但Derived Data Exterminator无疑是最便捷的那种。在我们将它集成到Xcode后，就可以一键清理Derived Data。<br>￼<br>7.QuickLocalization<br>你是否已经厌倦了反复写NSLocalizedString？如果是，那么QuickLocalization插件可以助你一臂之力。当你在编辑字符串的时候，只需要按下option+shift+d，就可以将@“Any String”转换成NSLocalizedString(@”Any String”, nil)。而且还可以通过修改配置来定义要出现在comment字段中的内容。我已经离不开它了！<br>6.KSImageNamed<br>过去，我不得不频繁查看资源文件夹以查找合适的图片的名称。使用KSImageNamed插件后，会自动弹出图片名称的列表以供选择，而且还有缩略图，十分便捷。<br>图片由Kent Sutherland提供<br>5.ShowInGithub<br>代码审查是Netguru大神们生活方式的一部分。尽管大部分bug会在此阶段被检查出来，但我们仍然会在使用他人代码的时候发现问题。这个时候，ShowInGithub大显身手的时候到了，只需要按下ctrl+C或ctrl+G，就可以立即打开commit或file页面，同时支持Github和BitBucket，非常棒！<br>￼<br>4.SCXcodeSwitchExpander<br>Switch语句相当繁琐。虽然它清楚地列出了在每种情况下应该处理的方式，但一个个填入枚举值那真是浪费时间。SCXcodeSwitchExpander插件可以帮我们完成这个工作，它可以自动获得所有的枚举值填入相应的位置，而我们只需在每个枚举值下面填入对应的逻辑即可，方便极了！<br>￼<br>3.VVDocumenter-Xcode<br>尽管给所有的文件都做上注释的感觉很棒，但是你是否想过这得花多少时间？事实上，感谢VVDocumenter-Xcode，真不需要多少时间。它可以自动解析方法的参数及返回值，并形成Javadoc风格的注释。我们写的所有开源代码都使用了这个插件。<br>￼<br>2.FuzzyAutocomplete<br>这个插件可以在编码的时候自动补全代码。它的强大之处在于，使用了与”Open Quickly”功能相同的算法，如，当你想使用“tableView:cellForRowAtIndexPath:”方法，原来需要输入冗长的“- (void)tableView:(UITableView *)tableViewce”才能匹配出方法，而现在只需要”- cellFor”就行，省事多了。<br>￼<br>1.XcodeBoost<br>这是我最喜欢的插件，我完全想象不了如果编码的时候没有它怎么办。通过配置，我们可以使用光标或者不精确的选择就可以剪切或者拷贝代码行，可以在粘贴代码的时候不触发代码格式化，还可以通过在.m文件中拷贝方法，粘贴进.h文件的时候就可以得到自动格式成的方法声明，还有好些功能都可以实现。XcodeBoost，值得你拥有！<br>￼<br>推荐应用<br>大部分时候，我使用Xcode进行编码，但同时我也会频繁使用其他的一些应用。<br>7.Status Barred<br>根据iTunesConnect Guidelines的要求，屏幕截图不应当包含状态栏，这个工具可以帮助我们平滑地去除状态栏，同时支持iPhone和iPad的屏幕截图。这个小应用虽然只做一件事，但是做得很好。<br>￼<br>6.MacDown<br>你是否已经厌倦了在没有预览的情况下写markdown文件？又或者你使用的编辑器需要按下按钮才能显示预览效果？MacDown是一款方便的的markdown编辑器，它可以在markdown代码右边实时显示预览效果。<br>￼<br>5.SimPholders<br>SimPholders是一个简单便捷的小应用，它会在Mac的工具栏上设置一个快捷按钮，开发者通过它就可以快速打开模拟器或是最近使用的应用。特别是当你需要处理应用文件夹内容的时候，你再也不需要一次次地点进模拟器和应用的文件夹了，用SimPholders就够了。<br>￼<br>4.NetworkLink Conditioner<br>这是一个来自苹果官方的工具，它可以模拟任何网络环境，如3G，Edge等等，也可以重新定义当前的网络环境，如网络延迟、带宽或丢包率。NetworkLink Conditioner也可以应用于真机，但是使用的时候需要小心，使用这个工具不仅仅对使用者起作用，还会影响整个网络。</p>
<p>3.RestConsole<br>Rest Console是一个基于Google Chrome的插件，它提供了一个简单易用的REST可视化界面，使得调试API的工作变得更加有趣。RestConsole可以将返回结果格式化，使之便于阅读。同时它也支持oAuth。</p>
<p>2.Chisel<br>使用LLDB可以显著减少开发者的调试时间。Facebook开发了一套用于LLDB的命令十分有效，特别是当出现了一些难以复现的问题的时候。虽然熟悉它需要一定的时间，但是绝对值得。</p>
<p>1.SQLiteManager<br>SQLiteManager是一个Firefox上的管理SQLite的小插件。在用到CoreData的时候配合使用很方便。我常常觉得Xcode应该集成这方面的功能。它很简洁，我很喜欢这一点。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xsdar.com1.z0.glb.clouddn.com/Alcatraz.png&quot; alt=&quot;&quot; title=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h5 id=&quot;￼简介&quot;&gt;&lt;a href=&quot;#￼简介&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
      <category term="工具" scheme="http://www.jeyblogs.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="插件" scheme="http://www.jeyblogs.com/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Mac测试模拟慢网速</title>
    <link href="http://www.jeyblogs.com/2015/09/21/Mac%E6%B5%8B%E8%AF%95%E6%A8%A1%E6%8B%9F%E6%85%A2%E7%BD%91%E9%80%9F/"/>
    <id>http://www.jeyblogs.com/2015/09/21/Mac测试模拟慢网速/</id>
    <published>2015-09-21T07:08:16.000Z</published>
    <updated>2016-08-30T10:15:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>先普及一下Kb,KB,Kbps,Mb,Mbps等一些列概念　<br>    1Byte = 8bit<br>    1KB (Kilobyte 千字节)=1024Byte<br>    1MB (Megabyte，兆字节，简称“兆”)=1024KB　　<br>    1GB (Gigabyte，吉字节，又称“千兆”)=1024MB<br>    1TB (Terabyte，太字节，或百万兆字节)=1024GB<br>    1KB=1024B<br>    1MB=1024KB<br>    1GB=1024MB 　<br>    1TB=1024GB</p>
<p>1    Kb和KB的区别：计算机中的信息都是二进制的0和1来表示，其中每一个0或1被称作一个位，用小写b表示，即bit（位）；大写B表示byte,即字节，一个字节＝八个位，即1B＝8b；前面的大写K表示千的意思，即千个位（Kb)或千个字节(KB)。表示文件的大小单位，一般都使用字节（KB）来表示文件的大小。<br>2    Kb和Kbps的区别：首先要了解的是，ps指的是/s，即每秒。Kbps指的是网络速度，也就是每秒钟传送多少个千位的信息（K表示千位，Kb表示的是多少千个位），为了在直观上显得网络的传输速度较快，一般公司都使用kb（千位）来表示，如果是KBps，则表示每秒传送多少千字节。1KBps＝8Kbps。ADSL上网时的网速是512Kbps,如果转换成字节，就是512/8＝64KBps(即64千字节每秒）。 1389.25 Kbps =173.65625KB／S .另外比如你家1M宽带，理论上下载速度最高能达到1M/8=1024k/8=128KB</p>
<p>3    Mbps,MB/s了解了面的2这个应该好理解了，直接举例,例如:560Mbps即560兆bit每秒，p就是“每”的意思，同”/“是一样的，但是如果你要用“MB”来计量的话，就要除以8（1Byte=8bit）了，也就是560Mbps/8=70MBps    </p>
<p>Mac下模拟慢网速其实apple已经提供工具了Network Link Conditioner，这个包含在Hardware IO Tools for Xcode工具包中，Xcode——Open Developer Tool——More Developer Tools<br>搜索hardware，找到对应版本的Hardware IO Tools for Xcode下载下来（不到30M吧），Network Link<br>看到下面的选择Network Link Conditioner.prefPane双击，打开系统偏好设置</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先普及一下Kb,KB,Kbps,Mb,Mbps等一些列概念　&lt;br&gt;    1Byte = 8bit&lt;br&gt;    1KB (Kilobyte 千字节)=1024Byte&lt;br&gt;    1MB (Megabyte，兆字节，简称“兆”)=1024KB　　&lt;br&gt;    1GB
    
    </summary>
    
      <category term="Mac" scheme="http://www.jeyblogs.com/categories/Mac/"/>
    
    
      <category term="模拟网速" scheme="http://www.jeyblogs.com/tags/%E6%A8%A1%E6%8B%9F%E7%BD%91%E9%80%9F/"/>
    
  </entry>
  
  <entry>
    <title>苹果联系邮箱大全</title>
    <link href="http://www.jeyblogs.com/2015/05/30/%E8%8B%B9%E6%9E%9C%E8%81%94%E7%B3%BB%E9%82%AE%E7%AE%B1%E5%A4%A7%E5%85%A8/"/>
    <id>http://www.jeyblogs.com/2015/05/30/苹果联系邮箱大全/</id>
    <published>2015-05-30T01:41:41.000Z</published>
    <updated>2016-08-30T09:52:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>苹果开发者热线: 4006701855<br>申请邓氏编码出问题了可以拨打客服热线: 4008202669<br>AppReview@apple.com<br>应用在提交后（处于“审核中”），应用和应用内购的状态<br>状态更新通知——与开发者遭拒和影响审核时间相关的信息<br>应用遭拒通知咨询-快速审核请求<br>iTSPayments@apple.com<br>支付状态查询<br>与苹果向开发者支付费用相关的问题<br>咨询财务报表<br>AppStoreNotices@apple.com<br>App Store内应用侵权问题，比如我们可以投诉“摩根书院”的关键字侵权<br>DevPrograms@apple.com<br>iDP或ADC查询；<br>程序信息、收益、账户信息；<br>修改邮箱地址、公司联系地址、团队代理人（代理人才有权生成发布证书）<br>ADC产品、硬件等退费<br>ADC网站查询：合作伙请求<br>iDP-DTS@apple.com<br>代码级别的提问<br>API使用-代码崩溃/如何使用和查看Crash logs<br>X-code使用问题, 证书问题<br>修改代码可能会引发iTC上传错误或应用遭拒的情况<br>注意区别于上边这个地址，99$的iDP每年有2次技术支持的机会，申请地址如下：<a href="https://developer.apple.com/membercenter/index.action#techSupport" target="_blank" rel="external">https://developer.apple.com/membercenter/index.action#techSupport</a><br>iTunesConnect@apple.com<br>iTC遇到的任何错误<br>应用/应用内购买设置和管理<br>应用在商店里/用户评论投诉等相关的事宜<br>推广码查询<br>编辑应用信息（名称、评分、关键词、定价、本地化等）<br>iTC 用户以及应用内购买测试用户设置<br>关键词/商店搜索查询<br>iTC登陆事宜<br>崩溃日志<br>对Contact Us的疑问等<br>iAD激活和获取iAd模板<br>iTSBanking@apple.com<br>更新银行账户信息<br>与银行账户信息相关的事宜<br>协助填写银行信息表格<br>所有的开发者可通过iTC Contact Us 模块来修改银行账户信息，将表格发至这个邮箱<br>iTSTax@apple.com<br>与收入和销售税有关的问题-协助填写报税表格<br>处理报税表格<br>iTunesAppReporting@apple.com<br>销售/销售趋势报告理解的问题<br>报告丢失问题<br>– 销售/销售趋势报告与财务报告之差异</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;苹果开发者热线: 4006701855&lt;br&gt;申请邓氏编码出问题了可以拨打客服热线: 4008202669&lt;br&gt;AppReview@apple.com&lt;br&gt;应用在提交后（处于“审核中”），应用和应用内购的状态&lt;br&gt;状态更新通知——与开发者遭拒和影响审核时间相关的信息&lt;
    
    </summary>
    
      <category term="Mac" scheme="http://www.jeyblogs.com/categories/Mac/"/>
    
    
      <category term="苹果邮箱" scheme="http://www.jeyblogs.com/tags/%E8%8B%B9%E6%9E%9C%E9%82%AE%E7%AE%B1/"/>
    
  </entry>
  
  <entry>
    <title>Jey的Github收藏</title>
    <link href="http://www.jeyblogs.com/2015/03/20/Jey%E7%9A%84Github%E6%94%B6%E8%97%8F/"/>
    <id>http://www.jeyblogs.com/2015/03/20/Jey的Github收藏/</id>
    <published>2015-03-20T07:29:40.000Z</published>
    <updated>2016-10-21T08:43:22.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>ARAnimation(封装的动画库):  <a href="https://github.com/AugustRush/ARAnimation" target="_blank" rel="external">https://github.com/AugustRush/ARAnimation</a></li>
<li>Masonry自动布局约束：<a href="https://github.com/SnapKit/Masonry" target="_blank" rel="external">https://github.com/SnapKit/Masonry</a></li>
<li>ALSystemUtilities：<a href="https://github.com/andrealufino/ALSystemUtilities" target="_blank" rel="external">https://github.com/andrealufino/ALSystemUtilities</a><br> 提供相当完整的 iOS 设备状态查询，包括电池、记忆体用量、网路状态、执行序数目或是越狱情况等等</li>
<li>YYText: <a href="https://github.com/ibireme/YYText" target="_blank" rel="external">https://github.com/ibireme/YYText</a><br> 显示和编辑富文本的文本框架。</li>
<li>AFNetworking: <a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">https://github.com/AFNetworking/AFNetworking</a><br> 网络请求封装，不用多说</li>
<li>SDWebImage：<a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">https://github.com/rs/SDWebImage</a><br> 对图片缓存库</li>
<li>MJRefresh：<a href="https://github.com/CoderMJLee/MJRefresh" target="_blank" rel="external">https://github.com/CoderMJLee/MJRefresh</a><br> 上下拉刷新ScrollView</li>
<li>MJExtension：<a href="https://github.com/CoderMJLee/MJExtension" target="_blank" rel="external">https://github.com/CoderMJLee/MJExtension</a><br> 是一套字典和模型Model之间互相转换的超轻量级框架</li>
<li>RTLabel：<a href="https://github.com/honcheng/RTLabel" target="_blank" rel="external">https://github.com/honcheng/RTLabel</a><br> 基于UILabel类的拓展,能够支持Html标记的富文本显示，它是基于Core Text,因此也支持Core Text上的一些东西。</li>
<li>TYSlidePageScrollView：<a href="https://github.com/12207480/TYSlidePageScrollView" target="_blank" rel="external">https://github.com/12207480/TYSlidePageScrollView</a><br>带header,footer,滑动菜单的，分页上下左右滑动的TYSlidePageScrollView</li>
<li>JZDragView：<a href="https://github.com/zys456465111/JZDragView" target="_blank" rel="external">https://github.com/zys456465111/JZDragView</a><br>能够往上或往下拖拉图片展现出更换图片时候的视差效果</li>
<li>LTInfiniteScrollView：<a href="https://github.com/ltebean/LTInfiniteScrollView" target="_blank" rel="external">https://github.com/ltebean/LTInfiniteScrollView</a><br>包含两种效果，一种是常见的横向无限滚动，一种是带有弹动效果的横向无限滚动</li>
<li>UzysAnimatedGifPullToRefresh：<a href="https://github.com/uzysjung/UzysAnimatedGifPullToRefresh" target="_blank" rel="external">https://github.com/uzysjung/UzysAnimatedGifPullToRefresh</a><br>只需要一些简单的代码就可以使用动态的 GIF 添加 PullToRefresh 效果到任意的 scrollView 中，上下拉刷新。</li>
<li>WebViewJavascriptBridge:   <a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="external">https://github.com/marcuswestin/WebViewJavascriptBridge</a><br>Obj-C和JavaScript通过UIWebViews/WebViews互通消息的一个iOS/OSX的桥梁</li>
<li>XMLDictionary:    <a href="https://github.com/nicklockwood/XMLDictionary" target="_blank" rel="external">https://github.com/nicklockwood/XMLDictionary</a><br>解析xml 将XML文件转换为NSDictionary</li>
<li>AMWaveTransition:   <a href="https://github.com/andreamazz/AMWaveTransition" target="_blank" rel="external">https://github.com/andreamazz/AMWaveTransition</a><br>实现了表格视图的自定义过渡效果。每一个单元格都实现了类似波形效果的动画切换</li>
<li>ParallaxTableViewHeader：<a href="https://github.com/Vinodh-G/ParallaxTableViewHeader" target="_blank" rel="external">https://github.com/Vinodh-G/ParallaxTableViewHeader</a><br>当 tableView 滚动时的时候 UITableView 头部视图的视差滚动视图。</li>
<li>PLPlayerKit：<a href="https://github.com/pili-engineering/PLPlayerKit" target="_blank" rel="external">https://github.com/pili-engineering/PLPlayerKit</a><br>是一个适用于 iOS 的音视频播放器 SDK，可高度定制化和二次开发，特色是支持 RTMP 和 HLS 直播流媒体播放，并且支持常见音视频文件例如 MP4/M4A 的播放。</li>
<li>MJParallaxCollectionView：<a href="https://github.com/mayuur/MJParallaxCollectionView" target="_blank" rel="external">https://github.com/mayuur/MJParallaxCollectionView</a><br>TableView的cell视觉差效果</li>
<li>YYKit：<a href="https://github.com/ibireme/YYKit" target="_blank" rel="external">https://github.com/ibireme/YYKit</a><br>是一组庞大、功能丰富的 iOS 组件。<br>• YYModel — 高性能的 iOS JSON 模型框架。<br>• YYCache — 高性能的 iOS 缓存框架。<br>• YYImage — 功能强大的 iOS 图像框架。<br>• YYWebImage — 高性能的 iOS 异步图像加载框架。<br>• YYText — 功能强大的 iOS 富文本框架。<br>• YYKeyboardManager — iOS 键盘监听管理工具。<br>• YYDispatchQueuePool — iOS 全局并发队列管理工具。<br>• YYAsyncLayer — iOS 异步绘制与显示的工具。<br>• YYCategories — 功能丰富的 Category 类型工具库。</li>
<li>FancyTabBar：<a href="https://github.com/marvelapp/FancyTabBar" target="_blank" rel="external">https://github.com/marvelapp/FancyTabBar</a><br>类似新浪微博那种弹出动画效果的TabBar</li>
<li>SDAutoLayout：<a href="https://github.com/gsdios/SDAutoLayout" target="_blank" rel="external">https://github.com/gsdios/SDAutoLayout</a><br>一行代码搞定自动布局！支持Cell和Tableview高度自适应，Label和ScrollView内容自适应，致力于做最简单易用的AutoLayout库。</li>
<li>SDCycleScrollView：<a href="https://github.com/gsdios/SDCycleScrollView" target="_blank" rel="external">https://github.com/gsdios/SDCycleScrollView</a><br>Autoscroll Banner. 无限循环图片、文字轮播器。</li>
<li>ZipArchive：<a href="https://github.com/ZipArchive/ZipArchive" target="_blank" rel="external">https://github.com/ZipArchive/ZipArchive</a><br>解压Zip包，解压文件</li>
<li>WZLBadge：<a href="https://github.com/weng1250/WZLBadge" target="_blank" rel="external">https://github.com/weng1250/WZLBadge</a><br>一行代码实现Badge效果，小红点</li>
<li>AGEmojiKeyboard：<a href="https://github.com/ayushgoel/AGEmojiKeyboard" target="_blank" rel="external">https://github.com/ayushgoel/AGEmojiKeyboard</a><br>iOS 上一个实现了对 emoji 表情支持的键盘控件</li>
<li>LBXScan：<a href="https://github.com/MxABC/LBXScan" target="_blank" rel="external">https://github.com/MxABC/LBXScan</a><br>二维码、扫码、扫一扫、ZXing和ios系统自带扫码封装，扫码界面效果封装</li>
<li>iOS-Oncenote：<a href="https://github.com/chenyufeng1991/iOS-Oncenote" target="_blank" rel="external">https://github.com/chenyufeng1991/iOS-Oncenote</a><br>一款类似于印象笔记Evernote的生活类iOS应用——朝夕笔记 Oncenote。</li>
<li>YTKNetwork：<a href="https://github.com/yuantiku/YTKNetwork" target="_blank" rel="external">https://github.com/yuantiku/YTKNetwork</a><br>猿题库 iOS 研发团队基于 AFNetworking 封装的 iOS 网络库，其实现了一套 High Level 的 API，提供了更高层次的网络访问抽象</li>
<li>uiimage-from-animated-gif：<a href="https://github.com/mayoff/uiimage-from-animated-gif" target="_blank" rel="external">https://github.com/mayoff/uiimage-from-animated-gif</a></li>
<li>GiFHUD：<a href="https://github.com/cemolcay/GiFHUD" target="_blank" rel="external">https://github.com/cemolcay/GiFHUD</a><br>progress hud for displaying only animated gif images. no labels (for now)</li>
<li>JSPatch：<a href="https://github.com/bang590/JSPatch" target="_blank" rel="external">https://github.com/bang590/JSPatch</a><br>热补丁</li>
<li>iosStudyResource：<a href="https://github.com/whytimber/iosStudyResource" target="_blank" rel="external">https://github.com/whytimber/iosStudyResource</a><br>牛人博客地址blogs</li>
<li>APNGKit：<a href="https://github.com/onevcat/APNGKit" target="_blank" rel="external">https://github.com/onevcat/APNGKit</a><br>一个高性能的框架用于在iOS中加载和展示APNG图片。</li>
<li>JBChartView：<a href="https://github.com/Jawbone/JBChartView" target="_blank" rel="external">https://github.com/Jawbone/JBChartView</a><br>实现效果非常不错的折线统计图和柱状统计图。可以动态绘制图表。手指在图表上滑动，会显示对应的数值。</li>
<li>JSQMessagesViewController：<a href="https://github.com/jessesquires/JSQMessagesViewController" target="_blank" rel="external">https://github.com/jessesquires/JSQMessagesViewController</a><br>是一个优雅的iOS消息类UI库。聊天界面封装</li>
<li>TLYShyNavBar: <a href="https://github.com/telly/TLYShyNavBar" target="_blank" rel="external">https://github.com/telly/TLYShyNavBar</a><br>自动滚动的导航条。</li>
<li>NVActivityIndicatorView:<a href="https://github.com/ninjaprox/NVActivityIndicatorView" target="_blank" rel="external">https://github.com/ninjaprox/NVActivityIndicatorView</a></li>
<li>CWStatusBarNotification:<a href="https://github.com/cezarywojcik/CWStatusBarNotification" target="_blank" rel="external">https://github.com/cezarywojcik/CWStatusBarNotification</a><br>一个在状态栏提醒信息的控件。可实现延迟自动消失</li>
<li>ResearchKit:<a href="https://github.com/ResearchKit/ResearchKit" target="_blank" rel="external">https://github.com/ResearchKit/ResearchKit</a><br>是苹果专为医学研究者打造的一款软件基础架构，用于帮助人们诊断各种疾病。</li>
<li>RDVTabBarController:<a href="https://github.com/robbdimitrov/RDVTabBarController" target="_blank" rel="external">https://github.com/robbdimitrov/RDVTabBarController</a><br>封装的TabBar</li>
<li>BButton ：<a href="https://github.com/mattlawer/BButton" target="_blank" rel="external">https://github.com/mattlawer/BButton</a></li>
<li>JDStatusBarNotification：<a href="https://github.com/jaydee3/JDStatusBarNotification" target="_blank" rel="external">https://github.com/jaydee3/JDStatusBarNotification</a><br>状态栏提醒信息的控件。</li>
<li>UITableView-FDTemplateLayoutCell：<a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell" target="_blank" rel="external">https://github.com/forkingdog/UITableView-FDTemplateLayoutCell</a><br>TableView自动布局，自动高度</li>
<li>PNChart：<a href="https://github.com/kevinzhow/PNChart" target="_blank" rel="external">https://github.com/kevinzhow/PNChart</a><br>折线统计图和柱状统计图，图表统计 </li>
<li>appirater：<a href="https://github.com/arashpayan/appirater" target="_blank" rel="external">https://github.com/arashpayan/appirater</a><br>一个可以直接使用到任何iPhone应用（iOS4.0及以上）中的开源类，用于提醒用户在打开App时，对应用进行评论或打分。AppStore评分</li>
<li>SearchHistory:<a href="https://github.com/zhiwupei/SearchHistory" target="_blank" rel="external">https://github.com/zhiwupei/SearchHistory</a><br>搜索历史标签</li>
<li>EAIntroView: <a href="https://github.com/ealeksandrov/EAIntroView" target="_blank" rel="external">https://github.com/ealeksandrov/EAIntroView</a><br>一个用来实现软件启动时介绍的控件，支持多个视图进行滑动显示。</li>
<li>SKTagView：<a href="https://github.com/zsk425/SKTagView" target="_blank" rel="external">https://github.com/zsk425/SKTagView</a><br>一款支持自动布局的标签tag.</li>
<li>iOS-Slide-Menu：<a href="https://github.com/aryaxt/iOS-Slide-Menu" target="_blank" rel="external">https://github.com/aryaxt/iOS-Slide-Menu</a><br>左侧菜单栏</li>
<li>JKCategories：<a href="https://github.com/shaojiankui/JKCategories" target="_blank" rel="external">https://github.com/shaojiankui/JKCategories</a><br>category，控件类别</li>
<li>NetworkEye：<a href="https://github.com/coderyi/NetworkEye" target="_blank" rel="external">https://github.com/coderyi/NetworkEye</a><br>网络调试库，可以监控App内HTTP请求并显示请求相关的详细信息，方便App开发的网络调试。</li>
<li>MDRadialProgress：<a href="https://github.com/mdinacci/MDRadialProgress" target="_blank" rel="external">https://github.com/mdinacci/MDRadialProgress</a><br>自定义显示进度状态视图</li>
<li>terminal-notifier:     <a href="https://github.com/julienXX/terminal-notifier" target="_blank" rel="external">https://github.com/julienXX/terminal-notifier</a><br>一个用来给 Mac OS X 用户发送通知的命令行工具</li>
<li>TTTAttributedLabel：<a href="https://github.com/TTTAttributedLabel/TTTAttributedLabel" target="_blank" rel="external">https://github.com/TTTAttributedLabel/TTTAttributedLabel</a><br>是 UILable 的改进，支持 NSAttributedStrings，据说用起来比较方便，但是需要增加很多代码，但比较灵活</li>
<li>CocoaLumberjack：<a href="https://github.com/CocoaLumberjack/CocoaLumberjack" target="_blank" rel="external">https://github.com/CocoaLumberjack/CocoaLumberjack</a><br>Mac和iOS上一个集快捷、简单、强大和灵活于一身的日志框架。</li>
<li>realm-cocoa：<a href="https://github.com/realm/realm-cocoa" target="_blank" rel="external">https://github.com/realm/realm-cocoa</a><br>是一个跨平台的移动数据库引擎，于 2014 年 7 月发布，准确来说，它是专门为移动应用所设计的数据持久化解决方案之一。</li>
<li>MobileProject：<a href="https://github.com/wujunyang/MobileProject" target="_blank" rel="external">https://github.com/wujunyang/MobileProject</a><br>开发框架</li>
<li>MagicalRecord：<a href="https://github.com/magicalpanda/MagicalRecord" target="_blank" rel="external">https://github.com/magicalpanda/MagicalRecord</a><br>第三方库实现的数据库</li>
<li>iOSBlogCN：<a href="https://github.com/tangqiaoboy/iOSBlogCN" target="_blank" rel="external">https://github.com/tangqiaoboy/iOSBlogCN</a><br>中文 iOS/Mac 开发博客列表</li>
<li>TopTabControl：<a href="https://github.com/liqiushui/TopTabControl" target="_blank" rel="external">https://github.com/liqiushui/TopTabControl</a><br>类似于网易新闻主界面中切换菜单的一个空间，定制自由度高。</li>
<li>IQKeyboardManager：<a href="https://github.com/hackiftekhar/IQKeyboardManager" target="_blank" rel="external">https://github.com/hackiftekhar/IQKeyboardManager</a><br>键盘</li>
<li>UICollectionView-Pure-code：<a href="https://github.com/cjq002/UICollectionView-Pure-code" target="_blank" rel="external">https://github.com/cjq002/UICollectionView-Pure-code</a><br>使用纯代码创建UICollectionView，自定义cell，添加类似tableViewHeader的头部。</li>
<li>iOS-H.264-hareware-encode-and-decode：<a href="https://github.com/LevyGG/iOS-H.264-hareware-encode-and-decode" target="_blank" rel="external">https://github.com/LevyGG/iOS-H.264-hareware-encode-and-decode</a><br>使用 Video Toolbox 进行H.264编码，视频播放</li>
<li>PLCameraStreamingKit：<a href="https://github.com/pili-engineering/PLCameraStreamingKit" target="_blank" rel="external">https://github.com/pili-engineering/PLCameraStreamingKit</a><br>视频播放，一个适用于 iOS 的 RTMP 直播推流 SDK，可高度定制化和二次开发。特色是支持 iOS Camera 画面捕获并进行 H.264 硬编码，以及支持 iOS 麦克风音频采样并进行 AAC 硬编码；同时，还根据移动网络环境的多变性，实现了一套可供开发者灵活选择的编码参数集合。</li>
<li>GPUImage：<a href="https://github.com/BradLarson/GPUImage" target="_blank" rel="external">https://github.com/BradLarson/GPUImage</a><br>一个基于GPU图像和视频处理的开源iOS框架，提供各种各样的图像处理滤镜，并且支持照相机和摄像机的实时滤镜； 基于GPU的图像加速，因此可以加速对实时摄像头视频、电影以及image的滤镜和其它效果处理，并且能够自定义图像滤镜</li>
<li>TZImagePickerController：<a href="https://github.com/banchichen/TZImagePickerController" target="_blank" rel="external">https://github.com/banchichen/TZImagePickerController</a><br>一个支持多选、选原图和视频的图片选择器，同时有预览功能，适配了iOS6789系统。</li>
<li>XMPPFramework：<a href="https://github.com/robbiehanson/XMPPFramework" target="_blank" rel="external">https://github.com/robbiehanson/XMPPFramework</a><br>一个OS X/iOS平台的开源项目，使用Objective-C实现了XMPP协议（RFC-3920），同时还提供了用于读写XML的工具，大大简化了基于XMPP的通信应用的开发。</li>
<li>CocoaAsyncSocket：<a href="https://github.com/robbiehanson/CocoaAsyncSocket" target="_blank" rel="external">https://github.com/robbiehanson/CocoaAsyncSocket</a><br>封装了CFSocket和CFSteam的TCP/IP socket网络库。它提供了异步操作，本地cocoa类的基于delegate的完整支持。</li>
<li>ACCodeSnippetRepositoryPlugin：<a href="https://github.com/acoomans/ACCodeSnippetRepositoryPlugin" target="_blank" rel="external">https://github.com/acoomans/ACCodeSnippetRepositoryPlugin</a><br>是 Xcode 的一个代码段的管理插件，像管理Xcode的插件一样，在Xcode里管理代码段是不容易的。该插件用Git仓库来同步Xcode的代码片段。</li>
<li>HZExtend：<a href="https://github.com/GeniusBrother/HZExtend" target="_blank" rel="external">https://github.com/GeniusBrother/HZExtend</a><br>1.解放VC:基于MVVM的思想，将数据相关的业务逻辑交给到ViewModel处理从而减少控制器的压力，降低代码耦合.<br>2.网络请求:基于AFN自定义了贴切业务逻辑的网络请求框架.<br>3.缓存体系:基于TMCache定制与业务逻辑相符的缓存体系.<br>4.数据元组:基于FMDB自定于实现了与表元组对应的数据模型.<br>5.URLManager:根据URL进行页面的跳转导航<br>6.一些常用的基础类扩展.</li>
<li>ReactiveCocoa：<a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="external">https://github.com/ReactiveCocoa/ReactiveCocoa</a><br>由Github开源的一个应用于iOS和OS开发的新框架,Cocoa是苹果整套框架的简称，因此很多苹果框架喜欢以Cocoa结尾。</li>
<li>Mantle：<a href="https://github.com/Mantle/Mantle" target="_blank" rel="external">https://github.com/Mantle/Mantle</a><br>iOS和Mac平台下基于Objective-C编写的一个简单高效的模型层框架。</li>
<li>UIGestureRecognizer：<a href="https://github.com/cjq002/UIGestureRecognizer" target="_blank" rel="external">https://github.com/cjq002/UIGestureRecognizer</a><br>Tap（点击）、Pinch（捏合）、Rotation（旋转）、Swipe（滑动）、Pan（拖移）、LongPress（长按）手势的创建和使用。</li>
<li>OWUProximityManager：<a href="https://github.com/ohwutup/OWUProximityManager" target="_blank" rel="external">https://github.com/ohwutup/OWUProximityManager</a><br>一个方便的 iBeacon + CoreBluetooth 管理器</li>
<li>DGAdLaunchView：<a href="https://github.com/Desgard/DGAdLaunchView" target="_blank" rel="external">https://github.com/Desgard/DGAdLaunchView</a><br>登录页广告</li>
<li>BetterDribbble：<a href="https://github.com/zangqilong198812/BetterDribbble" target="_blank" rel="external">https://github.com/zangqilong198812/BetterDribbble</a></li>
<li>XLVideoPlayer：<a href="https://github.com/ShelinShelin/XLVideoPlayer" target="_blank" rel="external">https://github.com/ShelinShelin/XLVideoPlayer</a><br>基于AVFoundation的视频播放器</li>
<li>BarrageRenderer：<a href="https://github.com/unash/BarrageRenderer" target="_blank" rel="external">https://github.com/unash/BarrageRenderer</a><br>开源弹幕渲染库.</li>
<li>JMHoledView：<a href="https://github.com/leverdeterre/JMHoledView" target="_blank" rel="external">https://github.com/leverdeterre/JMHoledView</a><br>添加一片圆形，方型，圆角方型以及自定义视图的高亮区域到视图当中。可以用于应用页面的某些强调说明，点击该区域支持delegate回调，指导操作页</li>
<li>PinYin4Objc：<a href="https://github.com/kimziv/PinYin4Objc" target="_blank" rel="external">https://github.com/kimziv/PinYin4Objc</a><br>最好用的汉字转拼音代码PinYin4Objc</li>
<li>JHChainableAnimations：<a href="https://github.com/jhurray/JHChainableAnimations" target="_blank" rel="external">https://github.com/jhurray/JHChainableAnimations</a><br>实现易读链式动画写法</li>
<li>Canvas：<a href="https://github.com/CanvasPod/Canvas" target="_blank" rel="external">https://github.com/CanvasPod/Canvas</a></li>
<li>iCarousel：<a href="https://github.com/nicklockwood/iCarousel" target="_blank" rel="external">https://github.com/nicklockwood/iCarousel</a><br>是一个用来简化在 iOS 上实现旋转木马时的视图切换效果，支持 iPad，提供多种切换效果。内容类似的页面需要并排列出来，供用户选择。iCarousel具有非常酷的3D效果，比如经典的CoverFlow, TimeMachine。另外还具有线性，圆柱状等其它效果。可用于图片选择，书籍选择，网页选择等。</li>
<li>DTCoreText：<a href="https://github.com/Cocoanetics/DTCoreText" target="_blank" rel="external">https://github.com/Cocoanetics/DTCoreText</a><br>iOS/OSX里的文字渲染引擎，在iOS/OSX上看到的所有文字在底层都是由CoreText去渲染。</li>
<li>DACircularProgress：<a href="https://github.com/danielamitay/DACircularProgress" target="_blank" rel="external">https://github.com/danielamitay/DACircularProgress</a><br>圆环的进度指示栏。圆形进度条</li>
<li>KRVideoPlayer：<a href="https://github.com/36Kr-Mobile/KRVideoPlayer" target="_blank" rel="external">https://github.com/36Kr-Mobile/KRVideoPlayer</a><br>类似Weico的播放器，支持竖屏模式下全屏播放</li>
<li>DAAppsViewController：<a href="https://github.com/danielamitay/DAAppsViewController" target="_blank" rel="external">https://github.com/danielamitay/DAAppsViewController</a><br>可以按多种方式查看App Store上的App，比如按照开发者的ID查看所有该开发者发布的App，或者按照App ID查看对应的某个App，或者按照App Bundle，也可以搜索某个关键字显示所有搜索结果。</li>
<li>SAMKeychain：<a href="https://github.com/soffes/SAMKeychain" target="_blank" rel="external">https://github.com/soffes/SAMKeychain</a><br>在应用间利用KeyChain共享数据</li>
<li>PINRemoteImage：<a href="https://github.com/pinterest/PINRemoteImage" target="_blank" rel="external">https://github.com/pinterest/PINRemoteImage</a><br>一个线程安全的，高性能，功能丰富的图像下载iOS库</li>
<li>FFmpeg：<a href="https://github.com/FFmpeg/FFmpeg" target="_blank" rel="external">https://github.com/FFmpeg/FFmpeg</a><br>FFmpeg发送流媒体的命令</li>
<li>XHImageViewer：<a href="https://github.com/JackTeam/XHImageViewer" target="_blank" rel="external">https://github.com/JackTeam/XHImageViewer</a><br>实现图片浏览功能，点击图片，开启图片全屏浏览模式。支持下载和显示网络图片</li>
<li>XXBRippleView：<a href="https://github.com/sixTiger/XXBRippleView" target="_blank" rel="external">https://github.com/sixTiger/XXBRippleView</a><br>水波纹效果</li>
<li>BTSimpleRippleButton：<a href="https://github.com/balram3429/BTSimpleRippleButton" target="_blank" rel="external">https://github.com/balram3429/BTSimpleRippleButton</a><br>水波纹效果按钮</li>
<li>DownloadButton：<a href="https://github.com/PavelKatunin/DownloadButton" target="_blank" rel="external">https://github.com/PavelKatunin/DownloadButton</a><br>自定义的 App Store 风格的下载按钮。可自定义设计组件，用 IB 进行编辑。</li>
<li>sdkdemoapp3.0：<a href="https://github.com/easemob/sdkdemoapp3.0_ios" target="_blank" rel="external">https://github.com/easemob/sdkdemoapp3.0_ios</a><br>环信</li>
<li>iOSKeyPointExploration：<a href="https://github.com/huang303513/iOSKeyPointExploration" target="_blank" rel="external">https://github.com/huang303513/iOSKeyPointExploration</a><br>GCD系列、Operation、KVC、KVO、Notification、响应链、模型解析、图片本地缓存、</li>
<li>TMCache：<a href="https://github.com/tumblr/TMCache" target="_blank" rel="external">https://github.com/tumblr/TMCache</a><br>缓存</li>
<li>FBAnnotationClustering：<a href="https://github.com/infinum/FBAnnotationClustering" target="_blank" rel="external">https://github.com/infinum/FBAnnotationClustering</a><br>地图适分法</li>
<li>MiaowShow：<a href="https://github.com/SunLiner/MiaowShow" target="_blank" rel="external">https://github.com/SunLiner/MiaowShow</a><br>iOS视频直播项目</li>
<li>BabyBluetooth：<a href="https://github.com/coolnameismy/BabyBluetooth" target="_blank" rel="external">https://github.com/coolnameismy/BabyBluetooth</a><br>蓝牙</li>
<li>BeaconOSX：<a href="https://github.com/mttrb/BeaconOSX" target="_blank" rel="external">https://github.com/mttrb/BeaconOSX</a></li>
<li><a href="https://github.com/coolnameismy/demo" target="_blank" rel="external">https://github.com/coolnameismy/demo</a><br>基础实用东西</li>
<li>hexo-theme-next：<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">https://github.com/iissnan/hexo-theme-next</a><br>next主题</li>
<li>PodsRepertory：<a href="https://github.com/heyuan110/PodsRepertory" target="_blank" rel="external">https://github.com/heyuan110/PodsRepertory</a></li>
<li>study：<a href="https://github.com/ming1016/study" target="_blank" rel="external">https://github.com/ming1016/study</a><br>学习资料</li>
<li>popping：<a href="https://github.com/schneiderandre/popping" target="_blank" rel="external">https://github.com/schneiderandre/popping</a><br>封装的动画库</li>
<li>AYBubbleView：<a href="https://github.com/AYJk/AYBubbleView" target="_blank" rel="external">https://github.com/AYJk/AYBubbleView</a><br>QQ / 仿qq的可拖拽未读气泡</li>
<li>TagView：<a href="https://github.com/xhzengAIB/TagView" target="_blank" rel="external">https://github.com/xhzengAIB/TagView</a><br>图片标签,分叉树标签</li>
<li>FunctionGuideController：<a href="https://github.com/wbxiaowangzi/FunctionGuideController" target="_blank" rel="external">https://github.com/wbxiaowangzi/FunctionGuideController</a><br>新功能引导控制器，传入两个数组就能使用，由于添加了自定义字体，和图片资源，所以比较大，代码本身并不大</li>
<li>KVOController：<a href="https://github.com/facebook/KVOController" target="_blank" rel="external">https://github.com/facebook/KVOController</a><br>FBKVOControlloer是FaceBook开源的一个 在 iOS，maxOS上使用 kvo的 开源库；<br>提供了block和@selector(SEL) 的回调操作，很方便实用</li>
<li>SXWaveAnimate:  <a href="https://github.com/dsxNiubility/SXWaveAnimate" target="_blank" rel="external">https://github.com/dsxNiubility/SXWaveAnimate</a><br>水花无限循环,灌水是用图片做的，现在已经改成了用贝塞尔曲线画,水波纹，百分比数字</li>
<li>Context-Menu.iOS：<a href="https://github.com/Yalantis/Context-Menu.iOS" target="_blank" rel="external">https://github.com/Yalantis/Context-Menu.iOS</a><br>可以为app的菜单添加漂亮的动画展开菜单，可自定义icon，并可根据自己的喜好设计单元格和布局。</li>
<li>BSCycleTextView：<a href="https://github.com/blurryssky/BSCycleTextView" target="_blank" rel="external">https://github.com/blurryssky/BSCycleTextView</a><br>滚动文字，循环</li>
<li>MarqueeLabel：<a href="https://github.com/cbpowell/MarqueeLabel" target="_blank" rel="external">https://github.com/cbpowell/MarqueeLabel</a><br>一个实现了超长文本的自动滚动显示，类似 HTML 里的 \<marquee\> 标签的行为。</marquee\></li>
<li>iOS_3D_ClusterAnnotation：<a href="https://github.com/hadesh/iOS_3D_ClusterAnnotation" target="_blank" rel="external">https://github.com/hadesh/iOS_3D_ClusterAnnotation</a><br>MAMapKit 点聚合，高德</li>
<li>JYJNavigationBar：<a href="https://github.com/jiangyongjian/JYJNavigationBar" target="_blank" rel="external">https://github.com/jiangyongjian/JYJNavigationBar</a><br>不一样的导航栏渐变效果</li>
<li>FDFullscreenPopGesture：<a href="https://github.com/forkingdog/FDFullscreenPopGesture" target="_blank" rel="external">https://github.com/forkingdog/FDFullscreenPopGesture</a><br>全屏POP手势动画，包含带顶栏标题和不带顶栏标题两种</li>
<li>MotionKit：<a href="https://github.com/MHaroonBaig/MotionKit" target="_blank" rel="external">https://github.com/MHaroonBaig/MotionKit</a><br>一款CoreMotion框架实用又简洁的的包装，并且全部使用Swift书写。Core Motion框架的作用是从设备硬件获取设备运动数据，并对获取到的数据进行了一层加工。数据来源可以是加速计，磁力仪和陀螺仪。另外你还可以从CMDeviceMotion获取提炼加工过的陀螺仪和加速计数据。</li>
<li>LocationManager：<a href="https://github.com/intuit/LocationManager" target="_blank" rel="external">https://github.com/intuit/LocationManager</a><br>定位管理</li>
<li>Reader：<a href="https://github.com/vfr/Reader" target="_blank" rel="external">https://github.com/vfr/Reader</a><br>阅读器，能够让 iOS 开发者轻而易举地在 iOS 设备屏幕上显示 PDF 文件。代码通用，不需要任何 XIB （因为所有 UI 元素都是代码生成的，具有极大的灵活性），运行于 iOS 4.0 及其以上版本设备中，同时还支持所有 Retina Display 设备。</li>
<li>Chameleon：<a href="https://github.com/ViccAlexander/Chameleon" target="_blank" rel="external">https://github.com/ViccAlexander/Chameleon</a><br>轻量级颜色框架</li>
<li>awesome-ios-cn：<a href="https://github.com/jobbole/awesome-ios-cn" target="_blank" rel="external">https://github.com/jobbole/awesome-ios-cn</a><br>iOS 资源大全中文版，内容包括：框架、组件、测试、Apple Store、SDK、XCode、网站、书籍等</li>
<li>Linkage：<a href="https://github.com/leejayID/Linkage" target="_blank" rel="external">https://github.com/leejayID/Linkage</a><br>【联动】：两个TableView之间的联动，TableView与CollectionView之间的联动，分类选择类似</li>
<li>FTreasure：<a href="https://github.com/Cherishforever/FTreasure" target="_blank" rel="external">https://github.com/Cherishforever/FTreasure</a><br>高仿网易1元夺宝</li>
<li>BGFMDB：<a href="https://github.com/huangzhibiao/BGFMDB" target="_blank" rel="external">https://github.com/huangzhibiao/BGFMDB</a><br>FMDB数据库封装</li>
<li>iOS-Echarts：<a href="https://github.com/Pluto-Y/iOS-Echarts" target="_blank" rel="external">https://github.com/Pluto-Y/iOS-Echarts</a><br>图表框架</li>
<li>NeiHanDuanZI：<a href="https://github.com/Charlesyaoxin/NeiHanDuanZI" target="_blank" rel="external">https://github.com/Charlesyaoxin/NeiHanDuanZI</a><br>纯干货：短期纯代码高仿优质《内涵段子》</li>
<li>SRClimate：<a href="https://github.com/guowilling/SRClimate" target="_blank" rel="external">https://github.com/guowilling/SRClimate</a><br>简约天气预报</li>
<li>SougouReading：<a href="https://github.com/YinTokey/SougouReading" target="_blank" rel="external">https://github.com/YinTokey/SougouReading</a><br>仿搜狗阅读 ，用 charles抓取数据</li>
<li>LZEasemob3：<a href="https://github.com/nacker/LZEasemob3" target="_blank" rel="external">https://github.com/nacker/LZEasemob3</a><br>酷信 | 高仿微信| WeChat | 高仿朋友圈 | moments| Github上最牛逼的高仿微信项目没有之一</li>
<li>SmallDay：<a href="https://github.com/ZhongTaoTian/SmallDay" target="_blank" rel="external">https://github.com/ZhongTaoTian/SmallDay</a><br>小日子 - By Swift 2.0</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;ARAnimation(封装的动画库):  &lt;a href=&quot;https://github.com/AugustRush/ARAnimation&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/AugustR
    
    </summary>
    
      <category term="Developer" scheme="http://www.jeyblogs.com/categories/Developer/"/>
    
    
      <category term="第三方资源" scheme="http://www.jeyblogs.com/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>iOS 开发调试技巧</title>
    <link href="http://www.jeyblogs.com/2014/12/26/iOS%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
    <id>http://www.jeyblogs.com/2014/12/26/iOS开发调试技巧/</id>
    <published>2014-12-26T03:30:40.000Z</published>
    <updated>2016-09-22T09:30:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于软件开发而言，调试是必须学会的技能，重要性不言而喻。对于调试的技能，基本上是可以迁移的，也就是说你以前在其他平台上掌握的很多调试技巧，很多也是可以用在iOS开发中。不同语言、不同IDE、不同平台的调试，有同性也有个性。今天我们就来学习一下iOS开发中的调试技巧，语言暂用为OC，IDE当然是强大的Xcode。首先说明下，Xcode已经为我们调试项目提供了极大的方便。<br>【1.普通断点】<br>断点(Breakpoint)绝对是调试程序的第一大选择，也是掌握的基础技能。顾名思义，当程序运行到断点处时会暂停运行。比如断点打在11行，那么程序就会停在11行（注意：程序只运行到了前10行，第11行其实还没有被执行！！！）。只要在代码行旁边点击，就能添加一个断点，再次点击，就能让断点不可用（disable了，仍然存在，只是不起作用了）。在某一行创建断点的快捷键是：command+\<br>￼<img src="http://7xsdar.com1.z0.glb.clouddn.com/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A71.png" alt=""><br><img src="http://7xsdar.com1.z0.glb.clouddn.com/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A72.png" alt=""><br>并能在调试过程中在下方看到参数的值：<br>￼<img src="http://7xsdar.com1.z0.glb.clouddn.com/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A73.png" alt=""></p>
<p>【2.条件断点】<br>以上的断点只是最普通的，我们还能对断点的属性进行配置，设置条件，使断点更加智能化，右键断点进入编辑对话框：<br>￼<img src="http://7xsdar.com1.z0.glb.clouddn.com/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A74.png" alt=""></p>
<p>我以一个循环作为测试代码：<br>￼<img src="http://7xsdar.com1.z0.glb.clouddn.com/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A75.png" alt=""><br>循环中的代码每次都要单步执行，可能这并不是我想要的。我想要在i为3的时候中断程序，进行调试，编写条件如下：<br>￼<img src="http://7xsdar.com1.z0.glb.clouddn.com/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A76.png" alt=""><br>设置i==3的条件后，程序就会在该条件时中断，而不会每次到达该位置都中断。中断时输出如下：<br>￼<img src="http://7xsdar.com1.z0.glb.clouddn.com/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A77.png" alt=""></p>
<p>同时也可以设置Ignore参数，会忽略前面n次的断点运行，会在第n+1次中断。<br>￼<img src="http://7xsdar.com1.z0.glb.clouddn.com/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A78.png" alt=""><br>调试输出如下：<br>￼<img src="http://7xsdar.com1.z0.glb.clouddn.com/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A79.png" alt=""></p>
<p>同时，还可以查看某个函数被调用的次数，设置Action参数如下，注意要选中Automatically continue after evaluating actions.<br>￼<img src="http://7xsdar.com1.z0.glb.clouddn.com/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A710.png" alt=""></p>
<p>输出结果如下：<br>￼<img src="http://7xsdar.com1.z0.glb.clouddn.com/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A711.png" alt=""></p>
<p>【3.异常断点】<br>断点的功能不限于上面所述。开发iOS知道，如果我们因为异常然后程序crash了，代码就直接跑到main.m的main函数中去了。为什么就不能跑到出现异常的代码中呢？？？异常断点就为我们解决该问题，程序就会在异常出现的那行代码终止。创建异常断点图例如下：<br>￼<img src="http://7xsdar.com1.z0.glb.clouddn.com/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A712.png" alt=""></p>
<p>如下所示就创建完成了。如果碰到异常crash时，尝试使用异常断点吧。<br>￼<img src="http://7xsdar.com1.z0.glb.clouddn.com/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A713.png" alt=""></p>
<p>【4.符号断点Symbolic Breakpoint】<br>符号断点的创建也同异常断点。一般符号断点可以在你指定的<a href="">类名 方法名</a>时中断执行。<br>￼<img src="http://7xsdar.com1.z0.glb.clouddn.com/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A714.png" alt=""></p>
<p>配置符号断点如下：可以当执行到ViewController类的viewDidLoad方法时中断执行。<br>￼<img src="http://7xsdar.com1.z0.glb.clouddn.com/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A715.png" alt=""></p>
<p>如果你的Symbol只写了一个函数名，那么就会在出现该函数名的地方就中断执行。如下，就会在运行到doAnimation的时候中断。是不是很强大呢？<br>￼<img src="http://7xsdar.com1.z0.glb.clouddn.com/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A716.png" alt=""></p>
<p>【5.Analyze分析器】<br>Analyze分析器是一种静态的工具，可以对我们的程序进行分析，找出我们未使用的变量，或一些死存储。执行Analyze如下：Product–>Analyze. 如下蓝色的标记就是静态分析的结果。<br>￼<img src="http://7xsdar.com1.z0.glb.clouddn.com/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A717.png" alt=""></p>
<p>￼<img src="http://7xsdar.com1.z0.glb.clouddn.com/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A718.png" alt=""></p>
<p>当然，我们可以设置在编译程序的时候同时Analyze，把下列选项设为Yes即可。<br>￼<img src="http://7xsdar.com1.z0.glb.clouddn.com/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A719.png" alt=""></p>
<p>【6.Profile检查器】<br>这个工具实在是太NB了，三言两语说不完，贴张图，大家感受一下，我会在以后的博客中慢慢讲解该工具的使用。同样在Product–>Profile中打开。<br>￼<img src="http://7xsdar.com1.z0.glb.clouddn.com/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A720.png" alt=""></p>
<p>【7.僵尸对象】<br>iOS中把那些已经release但还没完全消失的对象叫做僵尸对象，对已经release的对象再次释放，就会发生异常。虽然自从使用ARC后，由于对象释放产生的异常已经大大变少，但偶尔还会出现。开启僵尸对象模式后，就能快速定位到异常位置。开启方式如下：Product–>Scheme–>Edit Scheme. 勾选Enable Zombie Objects即可。<br>￼<img src="http://7xsdar.com1.z0.glb.clouddn.com/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A721.png" alt=""></p>
<p>【8.lldb命令】<br>Xcode中使用llvm编译器，公认为最好的C、C++、OC、Swift编译器。而lldb是llvm中的调试器，我们可以使用一些简单的命令进行调试，我还是把上面的循环代码作为测试代码。<br>￼<img src="http://7xsdar.com1.z0.glb.clouddn.com/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A722.png" alt=""></p>
<p>断点调试中，使用po命令、print命令在Console控制台打印出变量信息：<br>￼<img src="http://7xsdar.com1.z0.glb.clouddn.com/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A723.png" alt=""></p>
<p>【9.NSLog打印】<br>应该说NSLog打印信息是初学者最喜欢的调试手法，也是最简单的调试，通过打印出的信息查看程序运行的路径。但是打印出的信息较少，本身NSLog效率较低，有人使用宏做了部分优化，代码如下：能够打印出所在类名、所在方法名、详细时间、行号。</p>
<pre><code>[objc] view plain copy

print?￼￼
1    #import &quot;ViewController.h&quot;  
2      
3    #define NSLog(format, ...) do { \  
4    fprintf(stderr, &quot;&lt;%s : %d&gt; %s\n&quot;, \  
5    [[[NSString stringWithUTF8String:__FILE__] lastPathComponent] UTF8String], \  
6    __LINE__, __func__); \  
7    (NSLog)((format), ##__VA_ARGS__); \  
8    fprintf(stderr, &quot;-------\n&quot;); \  
9    } while (0)  
10      
11    @interface ViewController ()  
12      
13    @end  
14      
15    @implementation ViewController  
16      
17    - (void)viewDidLoad {  
18      
19        [super viewDidLoad];  
20        for (int i = 0; i &lt; 5; i++) {  
21            NSLog(@&quot;我的值：%d&quot;,i);  
22        }  
23    }  
24      
25    @end  
</code></pre><p>【10.生命周期方法init,dealloc】<br>对于ViewController来说，有两个生命周期函数我们可以进行重写，也就是init和dealloc方法。对于某些对象的状态，我们可以在这两个方法中查看。尤其是在dealloc中可以看到当ViewController退出的时候某个对象是否release。</p>
<pre><code>[objc] view plain copy

print?￼￼
1    - (instancetype)init  
2    {  
3        self = [super init];  
4        if (self) {  
5            //初始化语句；  
6        }  
7        return self;  
8    }  
9      
10    - (void)dealloc  
11    {  
12        //释放后调用；  
13    }  
</code></pre><p>【11.查看代码运行时间】<br>有时候我们想要准确的知道某段代码、某个循环执行的时间，然后分析效率等问题，这个时候就需要执行时间是多少。正好看到网上已经有人做了这个工作，我就直接摘下来了。正好也用了宏的方式计算时间，我们只要在需要计算时间的代码块前后写上TICK,TOCK宏即可。当然，原理也是非常的简单，也就是使用NSDate计算差值。</p>
<pre><code>[objc] view plain copy

print?￼￼
1    #import &quot;ViewController.h&quot;  
2      
3    #define TICK   NSDate *startTime = [NSDate date]  
4    #define TOCK   NSLog(@&quot;Time: %f&quot;, -[startTime timeIntervalSinceNow])  
5      
6    @interface ViewController ()  
7      
8    @end  
9      
10    @implementation ViewController  
11      
12    - (void)viewDidLoad {  
13      
14        [super viewDidLoad];  
15      
16        TICK;  
17        for (int i = 0; i &lt; 5; i++) {  
18            NSLog(@&quot;我的值：%d&quot;,i);  
19        }  
20        TOCK;  
21    }  
22      
23    @end  
</code></pre><p>打印结果如下：<br><img src="http://7xsdar.com1.z0.glb.clouddn.com/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A724.png" alt=""></p>
<p>【12.手机截屏】<br>手机截屏也算调试？哈哈。其实也算是开发中的一个小技巧哈。其实大家都会在iPhone上同时按电源键+Home键截屏，然后使用各种通讯软件发给其他人，这个略显不方便。我们来使用Xcode中的方式截屏。当手机接上电脑后，注意要把调试设备选为自己的手机：<br>￼<img src="http://7xsdar.com1.z0.glb.clouddn.com/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A725.png" alt=""><br>然后选择Debug–>View Debugging–>Take Screenshot…   .然后可以看到手机屏幕已经在你的电脑桌面了。是不是比直接在手机上操作方便多了呢？这样就可以快速的发给其他开发者、PM等人了。</p>
<p>【13.viewDidLoad不建议写太多代码】<br>       个人建议不要在viewDidLoad方法中写入太多代码。尤其是涉及该界面中的动画的时候，因为执行viewDidLoad方法的时候，界面可能还没完全加载出来，如果此时把动画放在viewDidLoad中，可能会造成动画无法显示。当然也不建议把耗时的网络请求和动画效果都放在viewDidLoad中，界面的阻塞也会造成动画无法显示。可以尝试把动画放在viewDidAppear,viewWillAppear方法中。对于这类涉及UI的问题，调试也是比较麻烦的。。。</p>
<p>【14.视图调试】<br>       如今iOS开发的UI设计有很多种方式，比如storyboard，xib，代码实现。对于stoayboard,xib可视化实现是比较简单的，但是对于一些“iOS老程序员”而言，都喜欢使用代码实现UI，并且可能UI层次还比较复杂。这样就给我们新接手项目的开发者带来很多困扰。如何快速查看一个复杂UI的界面层次和布局，最快的方法就是用到视图调试。<br>       当项目运行到某一个界面（可以是模拟器或真机）时，开启视图调试，点击按钮如图：<br>￼<img src="http://7xsdar.com1.z0.glb.clouddn.com/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A726.png" alt=""></p>
<p>这样就会进入试图调试，你可以很方便的查看这个界面。这里可以看到控件之间的层次关系。<br>￼<img src="http://7xsdar.com1.z0.glb.clouddn.com/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A727.png" alt=""></p>
<p>左侧的树形层次图可以在查看线程、队列和UI之间切换：<br>￼<img src="http://7xsdar.com1.z0.glb.clouddn.com/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A728.png" alt=""></p>
<p>￼<img src="http://7xsdar.com1.z0.glb.clouddn.com/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A729.png" alt=""></p>
<p>【15】常用的编译宏定义：可以让代码在不同的编译情况下执行。<br>（1）<strong>OPTIMIZE</strong>  :用于release和debug的判断，当选择了<strong>OPTIMIZE</strong>  时，可以让代码在release时执行，在debug时不执行。示例如下：</p>
<pre><code>[cpp] view plain copy

print?￼￼
1    #ifndef __OPTIMIZE__  
2        //这里执行的是debug模式下  
3    else  
4        //这里执行的是release模式下  
5    #endif  
</code></pre><p>（2）<strong>i386</strong> 与 <strong>x86_64</strong>   ：用于模拟器环境和真机环境的判断。满足该条件的代码只在模拟器下执行。示例代码如下：</p>
<pre><code>[cpp] view plain copy

print?￼￼
1    #if defined (__i386__) || defined (__x86_64__)  
2      
3        //模拟器下执行  
4    #else  
5      
6        //真机下执行  
7    #endif  
</code></pre><p>（3）<strong>IPHONE_OS_VERSION_MAX_ALLOWED  :当前编译的SDK版本，可以与</strong>IPHONE_9_0等宏定义进行比较，进行不同版本下代码的执行。示例如下：</p>
<pre><code>[cpp] view plain copy

print?￼￼
1    if (__IPHONE_OS_VERSION_MAX_ALLOWED == __IPHONE_9_0) {  
2            //如果当前SDK版本为9.0是执行这里的代码  
3        }else{  
4            //否则执行这里  
5        }  
</code></pre><p>【16】预编译宏在开发调试中非常有用，我们来仔细实践一下：<br>（1）if的预编译命令，根据后面的条件判断是否执行，因为这里条件为1，始终为真，所以在#if…#endif中的代码一定会执行。</p>
<pre><code>[objc] view plain copy

print?￼￼
1    #if 1  
2        //这里的代码一定会执行  
3      
4    #endif  
</code></pre><p>（2）这里的条件为0，为假，所以#if…#endif里面的代码一定不会执行。</p>
<pre><code>[objc] view plain copy

print?￼￼
1    #if 0  
2        //这里的代码一定不会执行  
3      
4    #endif  
</code></pre><p>（3）预编译命令还能根据是否宏定义某个标志，来选择是否执行。</p>
<pre><code>[objc] view plain copy

print?￼￼
1    #ifdef MY_TOP  
2        //如果 MY_TOP 被宏定义过，那么里面的代码会执行，否则不会执行。  
3      
4    #endif  
</code></pre><p>（4）预编译命令还可以进行嵌套，就像普通的条件判断一样。</p>
<pre><code>[objc] view plain copy

print?￼￼
1    #ifdef MY_TOP  
2        //如果 MY_TOP 被宏定义过，那么里面的代码会执行，否则不会执行。  
3      
4        #if 1  
5          //根据条件判断是否执行  
6        #endif  
7      
8        #ifdef MY_TOP2  
9        //嵌套判断  
10        #endif  
11      
12    #endif  
</code></pre><p>（5）既然有#ifdef…#endif,相反的，也有#ifndef…#endif,#ifndef的作用正好和#ifdef相反，如果宏定义没有被声明，那么将会执行执行；如果宏定义被声明了，就不会执行下面的代码。</p>
<pre><code>[objc] view plain copy

print?￼￼
1    #ifndef YOU_TOP  
2        //如果 YOU_TOP 没有被声明，就会执行里面的代码，否则不会执行。  
3      
4    #endif  
</code></pre><p>（6）既然是类似条件判断，那么就不得不说#else，在条件编译中，同样有#if…#else的判断，执行逻辑和普通的条件判断一样。</p>
<pre><code>[objc] view plain copy

print?￼￼
1    #ifdef MY_TOP  
2        //如果 MY_TOP 被宏定义过，那么这里的代码会执行，否则不会执行。  
3      
4        #else  
5        //要么执行else外面的，要么执行else里面的。  
6          #if 1  
7          //根据条件判断是否执行  
8          #endif  
9      
10    #endif  
</code></pre><p>（7）每出现一次if,就一定要有#endif去包裹，否则预编译器会提示你错误。如果有多层的嵌套，不同层次需要有适当的缩进。<br>（8）对于项目暂时不执行的代码，不建议使用注释代码去禁用。推荐使用预编译命令去打开关闭一段代码。</p>
<p>【17】#warning的使用<br>有时候在代码中出现大量黄色的警告是非常烦人的事情，大量的警告不利于代码的维护与调试。但是有时候我们需要手动去打一些警告，让我们记住这里应该要注意些什么重要的事情。在code review中，别人也会打一些#warning,提示你应该要注意什么问题，方便我们去查找问题和修改。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于软件开发而言，调试是必须学会的技能，重要性不言而喻。对于调试的技能，基本上是可以迁移的，也就是说你以前在其他平台上掌握的很多调试技巧，很多也是可以用在iOS开发中。不同语言、不同IDE、不同平台的调试，有同性也有个性。今天我们就来学习一下iOS开发中的调试技巧，语言暂用
    
    </summary>
    
      <category term="Xcode" scheme="http://www.jeyblogs.com/categories/Xcode/"/>
    
    
      <category term="调试" scheme="http://www.jeyblogs.com/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>bash快捷键</title>
    <link href="http://www.jeyblogs.com/2014/11/27/bash%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://www.jeyblogs.com/2014/11/27/bash快捷键/</id>
    <published>2014-11-27T09:49:22.000Z</published>
    <updated>2016-08-30T09:51:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>ctrl键组合<br>ctrl+a:光标移到行首。<br>ctrl+b:光标左移一个字母<br>ctrl+c:杀死当前进程。<br>ctrl+d:退出当前 Shell。<br>ctrl+e:光标移到行尾。<br>ctrl+h:删除光标前一个字符，同 backspace 键相同。<br>ctrl+k:清除光标后至行尾的内容。<br>ctrl+l:清屏，相当于clear。<br>ctrl+r:搜索之前打过的命令。会有一个提示，根据你输入的关键字进行搜索bash的history<br>ctrl+u: 清除光标前至行首间的所有内容。<br>ctrl+w: 移除光标前的一个单词<br>ctrl+t: 交换光标位置前的两个字符<br>ctrl+y: 粘贴或者恢复上次的删除<br>ctrl+d: 删除光标所在字母;注意和backspace以及ctrl+h的区别，这2个是删除光标前的字符<br>ctrl+f: 光标右移<br>ctrl+z : 把当前进程转到后台运行，使用’ fg ‘命令恢复。比如top -d1 然后ctrl+z，到后台，然后fg,重新恢复<br>esc组合<br>esc+d: 删除光标后的一个词<br>esc+f: 往右跳一个词<br>esc+b: 往左跳一个词<br>esc+t: 交换光标位置前的两个单词。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ctrl键组合&lt;br&gt;ctrl+a:光标移到行首。&lt;br&gt;ctrl+b:光标左移一个字母&lt;br&gt;ctrl+c:杀死当前进程。&lt;br&gt;ctrl+d:退出当前 Shell。&lt;br&gt;ctrl+e:光标移到行尾。&lt;br&gt;ctrl+h:删除光标前一个字符，同 backspace 键相
    
    </summary>
    
      <category term="Mac" scheme="http://www.jeyblogs.com/categories/Mac/"/>
    
    
      <category term="bash" scheme="http://www.jeyblogs.com/tags/bash/"/>
    
  </entry>
  
  <entry>
    <title>App被拒的各种原因</title>
    <link href="http://www.jeyblogs.com/2014/10/18/App%E8%A2%AB%E6%8B%92%E7%9A%84%E5%90%84%E7%A7%8D%E5%8E%9F%E5%9B%A0/"/>
    <id>http://www.jeyblogs.com/2014/10/18/App被拒的各种原因/</id>
    <published>2014-10-18T03:52:06.000Z</published>
    <updated>2016-08-30T10:00:13.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>Terms and conditions（法律与条款）<br>1.1<br>As a developer of applications for the App Store you are bound by the terms of the Program License Agreement (PLA), Human Interface Guidelines (HIG), and any other licenses or contracts between you and Apple. The following rules and examples are intended to assist you in gaining acceptance for your App in the App Store, not to amend or remove provisions from any other agreement.（作为App Store的应用开发者，你必须接受如下条款：Program License Agreement (PLA)，Human Interface Guidelines (HIG)，以及任何你与apple签订的许可和合同。以下规则和示例是为了协助你的应用更快通过审核上架，而不是修正或取代之前的条款。）</li>
<li>Functionality（功能）<br>2.1<br>Apps that crash will be rejected（存在Crash（崩溃，死机）的应用会被拒。）<br>2.2<br>Apps that exhibit bugs will be rejected（存在明显bug的应用会被拒。）<br>2.3<br>Apps that do not perform as advertised by the developer will be rejected（不符合开发者描述的应用会被拒。）<br>2.4<br>Apps that include undocumented or hidden features inconsistent with the description of the App will be rejected（有未说明或隐藏特性或有悖描述的应用会被拒。）<br>2.5<br>Apps that use non-public APIs will be rejected（使用非公开API的应用会被拒。）<br>2.6<br>Apps that read or write data outside its designated container area will be rejected（试图读写非允许范围内的数据的应用会被拒。）<br>2.7<br>Apps that download code in any way or form will be rejected（试图以任何方式方法下载代码的应用会被拒。）<br>2.8<br>Apps that install or launch other executable code will be rejected（安装或运行其他可执行代码的应用会被拒。）<br>2.9<br>Apps that are “beta”, “demo”, “trial”, or “test” versions will be rejected（任何“beta”，“演示（demo）”，“试用（trial）”或“测试（test）”版本的应用会被拒。）<br>2.10<br>iPhone Apps must also run on iPad without modification, at iPhone resolution, and at 2X iPhone 3GS resolution（iPhone应用必须可以无条件运行在iPad上，支持普通iPhone分辨率和2倍iPhone 3GS分辨率。）<br>2.11<br>Apps that duplicate Apps already in the App Store may be rejected, particularly if there are many of them, such as fart, burp, flashlight, and Kama Sutra Apps.（任何与App Store中上架应用重复的应用会被拒，尤其是已经有了很多的：如放屁，打嗝，手电照明和爱经。）<br>2.12<br>Apps that are not very useful, unique, are simply web sites bundled as Apps, or do not provide any lasting entertainment value may be rejected（没有用处的应用，web页面简单组合的应用，或任何哗众取宠，不能提供娱乐价值的应用会被拒。）<br>2.13<br>Apps that are primarily marketing materials or advertisements will be rejected（纯粹用于市场推广或广告的应用会被拒。）<br>2.14<br>Apps that are intended to provide trick or fake functionality that are not clearly marked as such will be rejected（有意提供隐蔽或虚假功能，却又不能明显标示的应用会被拒。）<br>2.15<br>Apps larger than 50MB in size will not download over cellular networks (this is automatically prohibited by the App Store)（大于20MB的应用无法通过蜂窝网络下载安装（App Store自动处理）。）<br>2.16<br>Multitasking Apps may only use background services for their intended purposes: VoIP, audio playback, location, task completion, local notifications, etc.（多任务应用只允许在后台运行如下相应的服务：VoIP，音频播放，地理位置，任务记录，本地提醒等。）<br>2.17<br>Apps that browse the web must use the iOS WebKit framework and WebKit Javascript（应用只允许通过iOS WebKit框架和WebKit Javascript访问web页面。）<br>2.18<br>Apps that encourage excessive consumption of alcohol or illegal substances, or encourage minors to consume alcohol or smoke cigarettes, will be rejected（鼓励酗酒，使用违法药物，或诱导未成年人饮酒，吸烟的应用会被拒。）<br>2.19<br>Apps that provide incorrect diagnostic or other inaccurate device data will be rejected（提供错误的系统信息或设备数据的应用会被拒。）<br>2.20<br>Developers “spamming” the App Store with many versions of similar Apps will be removed from the iOS Developer Program（通过许多版本的类似应用对App Store造成干扰的开发者会被取消IDP身份。）<br>2.21<br>Apps that are simply a song or movie should be submitted to the iTunes store. Apps that are simply a book should be submitted to the iBookstore.（歌曲和电影应该提交到iTunes store。书籍应该提交到iBookstore。）<br>2.22<br>Apps that arbitrarily restrict which users may use the App, such as by location or carrier, may be rejected（随意通过位置或运营商来限制用户使用的应用会被拒。）<br>2.23<br>Apps must follow the iOS Data Storage Guidelines or they will be rejected（加入iCloud支持后，应用必须遵守iOS数据存储指南（ iOS Data Storage Guidelines）否则将被拒。）<br>2.24<br>Apps that are offered in Newsstand must comply with schedules 1, 2 and 3 of the Developer Program License Agreement or they will be rejected（在Newsstand里提交的应用必须遵守Developer Program License Agreement的第1,2和3条，否则将被拒。）<br>2.25<br>Apps that display Apps other than your own for purchase or promotion in a manner similar to or confusing with the App Store will be rejected（与App Store类似的推荐或为其他应用做广告的应用将无法通过App Store审核。）</li>
<li>Metadata (name, descriptions, ratings, rankings, etc)（描述数据（名称，描述，评级，分类等））<br>3.1<br>Apps or metadata that mentions the name of any other mobile platform will be rejected（应用或者元数据中提到其他任意移动平台会被拒。）<br>3.2<br>Apps with placeholder text will be rejected（描述数据有未填写项，存留占位符文本会被拒。）<br>3.3<br>Apps with descriptions not relevant to the application content and functionality will be rejected（描述中提到与应用内容和功能无关信息会被拒。）<br>3.4<br>App names in iTunes Connect and as displayed on a device should be similar, so as not to cause confusion（应用在iTunes Connect与设备上显示的名称应该类似，否则会造成混淆。）<br>3.5<br>Small and large App icons should be similar, so as to not to cause confusion（不同尺寸的icon要一致，否则会造成混淆。）<br>3.6<br>Apps with App icons and screenshots that do not adhere to the 4+ age rating will be rejected（图标与截屏不符合4+年龄评级的应用会被拒。）<br>3.7<br>Apps with Category and Genre selections that are not appropriate for the App content will be rejected（应用的内容与所选分类和风格不符会被拒。）<br>3.8<br>Developers are responsible for assigning appropriate ratings to their Apps. Inappropriate ratings may be changed/deleted by Apple（开发者有责任把应用放到恰当的分级（Rating）。不恰当的评级可能会被Apple修改，甚至删除。）<br>3.9<br>Developers are responsible for assigning appropriate keywords for their Apps. Inappropriate keywords may be changed/deleted by Apple（开发者有责任给应用撰写恰当的关键词。不恰当的关键词可能会被Apple修改，甚至删除。）<br>3.10<br>Developers who attempt to manipulate or cheat the user reviews or chart ranking in the App Store with fake or paid reviews, or any other inappropriate methods will be removed from the iOS Developer Program（通过伪造，付费评价或其他非正规手段，获取App Store中较好的评价与星级的开发者会被取消IDP身份。）<br>3.11<br>Apps which recommend that users restart their iOS device prior to installation or launch may be rejected（任何提示需要用户重启iOS设备来安装或运行的应用会被拒。）<br>3.12<br>Apps should have all included URLs fully functional when you submit it for review, such as support and privacy policy URLs（应用在提交审核过程中，所有涉及到的URL都要处于正常运行状态，例如保密协议，相关支持页面等。）</li>
<li>Location（位置）<br>4.1<br>Apps that do not notify and obtain user consent before collecting, transmitting, or using location data will be rejected（未提示用户且获得用户允许之前收集，传输或使用位置数据的应用会被拒。）<br>4.2<br>Apps that use location-based APIs for automatic or autonomous control of vehicles, aircraft, or other devices will be rejected（使用location-based API来自动控制车辆，飞行器或其他设备的应用会被拒。）<br>4.3<br>Apps that use location-based APIs for dispatch, fleet management, or emergency services will be rejected（使用location-based API进行调度，队伍管理或应急服务的而应用会被拒。）<br>4.4<br>Location data can only be used when directly relevant to the features and services provided by the App to the user or to support approved advertising uses（位置数据只能用于应用提供的直接相关功能或服务，或者有授权的广告。）</li>
<li>Push notifications（提醒推送）<br>5.1<br>Apps that provide Push Notifications without using the Apple Push Notification (APN) API will be rejected（不使用Apple Push Notification（APN） API提供消息推送的应用会被拒。）<br>5.2<br>Apps that use the APN service without obtaining a Push Application ID from Apple will be rejected（使用APN服务却没从Apple获取一个Push Application ID的应用会被拒。）<br>5.3<br>Apps that send Push Notifications without first obtaining user consent will be rejected（在首次推送消息之前未取得的用户允许的应用会被拒。）<br>5.4<br>Apps that send sensitive personal or confidential information using Push Notifications will be rejected（使用提醒推送服务推送敏感的个人或机密信息的应用会被拒。）<br>5.5<br>Apps that use Push Notifications to send unsolicited messages, or for the purpose of phishing or spamming will be rejected（使用提醒推送发送主动消息，欺骗或干扰信息的应用会被拒。）<br>5.6<br>Apps cannot use Push Notifications to send advertising, promotions, or direct marketing of any kind（应用不可以使用提醒推送发送广告，活动或任何形式的直接推广信息。）<br>5.7<br>Apps cannot charge users for use of Push Notifications（应用不可以提供收费的提醒推送服务。）<br>5.8<br>Apps that excessively use the network capacity or bandwidth of the APN service or unduly burden a device with Push Notifications will be rejected（使用APN服务过度占用网络带宽或容量或通过提醒推送大量占用系统资源的应用会被拒。）<br>5.9<br>Apps that transmit viruses, files, computer code, or programs that may harm or disrupt the normal opera tion of the APN service will be rejected（传输病毒，文件，代码或程序，导致破坏或扰乱正常的APN服务操作的应用会被拒。）</li>
<li>Game Center（游戏中心）<br>6.1<br>Apps that display any Player ID to end users or any third party will be rejected（向终端用户或第三方展示Player ID的应用会被拒。）<br>6.2<br>Apps that use Player IDs for any use other than as approved by the Game Center terms will be rejected（Player ID被用于Game Center条款款意外的用途的应用会被拒。）<br>6.3<br>Developers that attempt to reverse lookup, trace, relate, associate, mine, harvest, or otherwise exploit Player IDs, alias, or other information obtained through the Game Center will be removed from the iOS Developer Program（试图通过Game Center反查，跟踪，描述，关联，发掘，收割，或利用Player ID，别名或其他信息的开发者会被取消IDP身份。）<br>6.4<br>Game Center information, such as Leaderboard scores, may only be used in Apps approved for use with the Game Center（Game Center信息，例如Leaderboard得分，只能通过Game Center用于应用中。）<br>6.5<br>Apps that use Game Center service to send unsolicited messages, or for the purpose of phishing or spamming will be rejected（使用Game Center发送主动消息，欺骗或干扰信息的应用会被拒。）<br>6.6<br>Apps that excessively use the network capacity or bandwidth of the Game Center will be rejected（使用Game Center过度占用网络带宽或容量的应用会被拒。）<br>6.7<br>Apps that transmit viruses, files, computer code, or programs that may harm or disrupt the normal operation of the Game Center service will be rejected（传输病毒，文件，代码或程序，导致破坏或扰乱正常的Game Center操作的应用会被拒。）</li>
<li>Advertising（广告）<br>7.1<br>Apps that artificially increase the number of impressions or click-throughs of ads will be rejected（人工刷广告浏览或点击率的应用会被拒。）<br>7.2<br>Apps that contain empty iAd banners will be rejected（带有空iAd banner广告的应用会被拒。）<br>7.3<br>Apps that are designed predominantly for the display of ads will be rejected（设计主要用来展示广告的应用会被拒。）</li>
<li>Trademarks and trade dress（商标权与商标外观）<br>8.1<br>Apps must comply with all terms and conditions explained in the Guidelines for Using Apple Trademarks and Copyrights and the Apple Trademark List（应用必须遵守Guidelines for Using Apple Trademarks and Copyrights 和Apple Trademark List中描述的所有条款和条件。）<br>8.2<br>Apps that suggest or infer that Apple is a source or supplier of the App, or that Apple endorses any particular representation regarding quality or functionality will be rejected（任何误导或暗示Apple为该应用来源或提供商，或Apple以任何形式认可其质量或功能的应用会被拒。）<br>8.3<br>Apps which appear confusingly similar to an existing Apple product or advertising theme will be rejected（外观与现有Apple产品或广告主题类似或混淆的应用会被拒）<br>8.4<br>Apps that misspell Apple product names in their App name (i.e., GPS for Iphone, iTunz) will be rejected（应用名称中出现错误的Apple产品拼写（如，GPS for IPhone， iTunz）的应用会被拒。）<br>8.5<br>Apps may not use protected third party material such as trademarks, copyrights, patents or violate 3rd party terms of use. Authorization to use such material must be provided upon request.（使用受保护的第三方资源（商标，版权，商业机密，以及其他私有内容），如果要求请提供一份文本形式的使用授权。）</li>
<li>Media content（媒体内容）<br>9.1<br>Apps that do not use the MediaPlayer framework to access media in the Music Library will be rejected（使用MediaPlayer框架以外的方法访问Music Library中媒体数据的应用会被拒。）<br>9.2<br>App user interfaces that mimic any iPod interface will be rejected（用户界面模仿任何iPod界面的应用会被拒。）<br>9.3<br>Audio streaming content over a cellular network may not use more than 5MB over 5 minutes（通过蜂窝网络传输的流媒体音频内容不得超过5MB或多余5分钟。）<br>9.4<br>Video streaming content over a cellular network longer than 10 minutes must use HTTP Live Streaming and include a baseline 64 kbps audio-only HTTP Live stream（通过蜂窝网络传输超过10分钟流媒体视频内容，必须使用HTTP Live Streaming，并包含一条基线64kbps的音频HTTP Live流。）</li>
<li>User interface（用户界面）<br>10.1<br>Apps must comply with all terms and conditions explained in the Apple iOS Human Interface Guidelines（应用必须遵守Apple iOS Human Interface Guidelines中的所有条款和条件。）<br>10.2<br>Apps that look similar to Apps bundled on the iPhone, including the App Store, iTunes Store, and iBookstore, will be rejected（ 外观与iPhone自带应用（如：App Store，iTunes Store和iBookstore）相似的应用会被拒。）<br>10.3<br>Apps that do not use system provided items, such as buttons and icons, correctly and as described in the Apple iOS Human Interface Guidelines may be rejected（不按照Apple iOS Human Interface Guidelines中的描述正确使用系统控件比如按钮，图标等的应用会被拒。）<br>10.4<br>Apps that create alternate desktop/home screen environments or simulate multi-App widget experiences will be rejected（试图创建多桌面/主屏环境或模拟多Widget应用工具的应用会被拒。）<br>10.5<br>Apps that alter the functions of standard switches, such as the Volume Up/Down and Ring/Silent switches, will be rejected（ 修改标准开关标准功能例如：音量增加／减少，响铃／震动的应用会被拒。）<br>10.6<br>Apple and our customers place a high value on simple, refined, creative, well thought through interfaces. They take more work but are worth it. Apple sets a high bar. If your user interface is complex or less than very good, it may be rejected（Apple和我们的用户都界面报以很高期望，希望他设计的超级简洁，精致，充满创造力，深思熟虑。做到这些确实会消耗很多精力，但是值得。Apple在这方面要求非常高。如果你的用户界面过于复杂，甚至仅仅是不够好，都可能被拒。）</li>
<li>Purchasing and currencies（购买与流通货币）<br>11.1<br>Apps that unlock or enable additional features or functionality with mechanisms other than the App Store will be rejected（通过App Store以外的渠道解锁或开启附加属性或功能的应用会被拒。）<br>11.2<br>Apps utilizing a system other than the In-App Purchase API (IAP) to purchase content, functionality, or services in an App will be rejected（ 使用In App Purchase API (IAP)以外的系统提供购买内容，功能或服务的应用会被拒。）<br>11.3<br>Apps using IAP to purchase physical goods or goods and services used outside of the application will be rejected（使用IAP为与应用无关的实体商品或商品服务收费的应用会被拒。）<br>11.4<br>Apps that use IAP to purchase credits or other currencies must consume those credits within the application（应用使用IAP购买积分（Credit）或其他货币，必须在应用中消费。）<br>11.5<br>Apps that use IAP to purchase credits or other currencies that expire will be rejected（使用IAP购买的积分（Credit）或货币会过期的应用会被拒）<br>11.6<br>Content subscriptions using IAP must last a minimum of 7 days and be available to the user from all of their iOS devices（ 使用IAP收费订阅的内容至少要在7天内有效，而且允许在所有iOS设备间共享。）<br>11.7<br>Apps that use IAP to purchase items must assign the correct Purchasability type（用到IAP收费项目的应用必须分派到正确的收费类目中。）<br>11.8<br>Apps that use IAP to purchase access to built-in capabilities provided by iOS, such as the camera or the gyroscope, will be rejected（ 使用IAP向用户收费以获取iOS内建功能（如摄像头，陀螺仪）的应用会被拒。）<br>11.9<br>Apps containing “rental” content or services that expire after a limited time will be rejected（ 包含“出租”内容或服务的应用，在一段时间实效的会被拒。）<br>11.10<br>Insurance applications must be free, in legal-compliance in the regions distributed, and cannot use IAP（保险类应用必须免费，遵守发布地区的法律，并且不允许使用IAP。）<br>11.11<br>In general, the more expensive your App, the more thoroughly we will review it（一般来说，越贵的应用审核就越仔细彻底。）<br>11.12<br>Apps offering subscriptions must do so using IAP, Apple will share the same 70/30 revenue split with developers for these purchases, as set forth in the Developer Program License Agreement.（提供收费订阅的应用必须使用IAP，Apple将会按照Developer Program License Agreement中约定的70/30的比例与开发者分账。）<br>11.13<br>Apps that link to external mechanisms for purchases or subscriptions to be used in the App, such as a “buy” button that goes to a web site to purchase a digital book, will be rejected（应用中如果提供了IAP以外的收费或订阅机制，如：“buy”按钮，跳转到一个购买电子书的web页面，会被拒。）<br>11.14<br>Apps can read or play approved content (specifically magazines, newspapers, books, audio, music, and video) that is subscribed to or purchased outside of the App, as long as there is no button or external link in the App to purchase the approved content. Apple will not receive any portion of the revenues for approved content that is subscribed to or purchased outside of the App（ 应用可以阅读或播放任何在应用以外取得授权的内容（包括指定的杂志，报纸，书籍，音频，音乐和视频），只要在应用中不允许出现获取授权的收费链接或按钮。Apple不会对在应用外订阅或购买授权项目收取任何费用。）<br>11.15<br>Apps may only use auto renewing subscriptions for periodicals (newspapers, magazines), business Apps (enterprise, productivity, professional creative, cloud storage) and media Apps (video, audio, voice), or the App will be rejected.（应用只能自动更新订阅的期刊（报纸、杂志），自动更新商业应用（企业、生产力、专业创意、云存储）和媒体应用（视频、音频，声音）将被拒绝。）</li>
<li>Scraping and aggregation（抓去与整合）<br>12.1<br>Applications that scrape any information from Apple sites (for example from apple.com, iTunes Store, App Store, iTunes Connect, Apple Developer Programs, etc) or create rankings using content from Apple sites and services will be rejected（从Apple的页面（如：apple.com, iTunes Store, App Store, iTunes Connect, Apple Developer Programs, 等）抓取内容，或利用Apple页面和服务中的内容进行排名的应用会被拒。）<br>12.2<br>Applications may use approved Apple RSS feeds such as the iTunes Store RSS feed（ 应用可以使用授权的Apple RSS，例如iTunes Store RSS。）<br>12.3<br>Apps that are simply web clippings, content aggregators, or a collection of links, may be rejected（简单的web页面裁剪，内容整合或链接收集应用会被拒。）</li>
<li>Damage to device（损害设备）<br>13.1<br>Apps that encourage users to use an Apple Device in a way that may cause damage to the device will be rejected（任何怂恿用户做出可能损坏Apple设备的行为的应用会被拒。）<br>13.2<br>Apps that rapidly drain the device’s battery or generate excessive heat will be rejected（快速耗光设备电量或产生大量热量的应用会被拒。）</li>
<li>Personal attacks（人身攻击）<br>14.1<br>Any App that is defamatory, offensive, mean-spirited, or likely to place the targeted individual or group in harms way will be rejected（ 任何涉嫌诽谤，侮辱，狭隘内容或打击个人或团体的应用会被拒。）<br>14.2<br>Professional political satirists and humorists are exempt from the ban on offensive or mean-spirited commentary（职业政治讽刺家和幽默作家不受该诽谤和狭隘条款约束。）</li>
<li>Violence（暴力）<br>15.1<br>Apps portraying realistic images of people or animals being killed or maimed, shot, stabbed, tortured or injured will be rejected（展示人或动物被杀戮，致残，枪击，针刺或其他伤害的真实图片的应用会被拒）<br>15.2<br>Apps that depict violence or abuse of children will be rejected（描述暴力或虐待儿童的应用会被拒。）<br>15.3<br>“Enemies” within the context of a game cannot solely target a specific race, culture, a real government or corporation, or any other real entity（游戏中的“敌人”不能单独的设定为某特定比赛，文化，真实的政府或组织，或者任何现实事物。）<br>15.4<br>Apps involving realistic depictions of weapons in such a way as to encourage illegal or reckless use of such weapons will be rejected（含有以鼓励非法或鲁莽使用的方式描述真实武器的应用会被拒。）<br>15.5<br>Apps that include games of Russian roulette will be rejected（ 带有俄罗斯轮盘游戏的应用会被拒。）</li>
<li>Objectionable content（负面内容）<br>16.1<br>Apps that present excessively objectionable or crude content will be rejected（介绍过度三俗和粗鲁内容的应用会被拒。）<br>16.2<br>Apps that are primarily designed to upset or disgust users will be rejected（设计来惹怒或恶心用户的应用会被拒。）</li>
<li>Privacy（隐私）<br>17.1<br>Apps cannot transmit data about a user without obtaining the user’s prior permission and providing the user with access to information about how and where the data will be used（在未获得用户事先允许，或未告知用户信息将被如何，在哪里使用的情况下，应用不可以传输用户数据。）<br>17.2<br>Apps that require users to share personal information, such as email address and date of birth, in order to function will be rejected（要求用户提供个人信息，如邮箱地址，生日等，才能使用其功能的应用会被拒。）<br>17.3<br>Apps that target minors for data collection will be rejected（专门收集未成年人数据的应用会被拒。）</li>
<li>Pornography（色情）<br>18.1<br>Apps containing pornographic material, defined by Webster’s Dictionary as “explicit descriptions or displays of sexual organs or activities intended to stimulate erotic rather than aesthetic or emotional feelings”, will be rejected（含有韦氏词典中定义的色情素材（explicit descriptions or displays of sexual organs or activities intended to stimulate erotic rather than aesthetic or emotional feelings）的应用会被拒。）<br>18.2<br>Apps that contain user generated content that is frequently pornographic (ex “Chat Roulette” Apps) will be rejected（经常有用户提供色情内容（例如：Chat Roulette <a href="http://en.wikipedia.org/wiki/Chatroulette" target="_blank" rel="external">http://en.wikipedia.org/wiki/Chatroulette</a> ）的应用会被拒。）</li>
<li>Religion, culture, and ethnicity（信仰，文化和种族）<br>19.1<br>Apps containing references or commentary about a religious, cultural or ethnic group that are defamatory, offensive, mean-spirited or likely to expose the targeted group to harm or violence will be rejected（带有对一种信仰，文化或种族进行诽谤，侮辱，狭隘，或以他们为目标的暴力或伤害内容的应用会被拒。）<br>19.2<br>Apps may contain or quote religious text provided the quotes or translations are accurate and not misleading. Commentary should be educational or informative rather than inflammatory（ 应用若带有或应用对一种信仰的文字描述，那么这个引用或翻译必须是精确，无歧义的。注释内容可以具有教育性，信息性，但不可以为煽动性。）</li>
<li>Contests, sweepstakes, lotteries, and raffles（竞赛，赌博，彩票和抽奖）<br>20.1<br>Sweepstakes and contests must be sponsored by the developer/company of the App（赌博和竞赛必须是由应用开发者或所有公司发起资助的。）<br>20.2<br>Official rules for sweepstakes and contests, must be presented in the App and make it clear that Apple is not a sponsor or involved in the activity in any manner（ 应用中必须展示赌博和竞赛的官方条款，并声明Apple不是资助者，并且在任何情况下与此事无关。）<br>20.3<br>It must be permissible by law for the developer to run a lottery App, and a lottery App must have all of the following characteristics: consideration, chance, and a prize（开发者必须经过法律允许才能上线一款抽奖应用，而且抽奖应用必须具备以下要素：报酬，机会，和奖金。)<br>20.4<br>Apps that allow a user to directly purchase a lottery or raffle ticket in the App will be rejected（直接允许用户在应用中购买彩票或抽奖的应用会被拒。）</li>
<li>Charities and contributions（慈善与捐助）<br>21.1<br>Apps that include the ability to make donations to recognized charitable organizations must be free（含有向已认证的慈善机构捐助功能的应用必须是免费的。）<br>21.2<br>The collection of donations must be done via a web site in Safari or an SMS（慈善募捐必须通过短信息或通过Safari访问web页面完成。）</li>
<li>Legal requirements（法律要求）<br>22.1<br>Apps must comply with all legal requirements in any location where they are made available to users. It is the developer’s obligation to understand and conform to all local laws（应用必须遵守所有发布地区当地法律。开发者有义务了解和遵守各地的法律。）<br>22.2<br>Apps that contain false, fraudulent or misleading representations or use names or icons similar to other Apps will be rejected（ 任何带有虚假，欺诈和带有歧义的内容的应用会被拒。）<br>22.3<br>Apps that solicit, promote, or encourage criminal or clearly reckless behavior will be rejected（ 任何召集，推销和股东犯罪和鲁莽行为的应用会被拒。）<br>22.4<br>Apps that enable illegal file sharing will be rejected（非法文件共享应用会被拒。）<br>22.5<br>Apps that are designed for use as illegal gambling aids, including card counters, will be rejected（任何设计用来非法赌博工具，包括算牌的应用会被拒。）<br>22.6<br>Apps that enable anonymous or prank phone calls or SMS/MMS messaging will be rejected（ 提供知识拨打电话或知识发送短消息/彩信功能的应用会被拒。）<br>22.7<br>Developers who create Apps that surreptitiously attempt to discover user passwords or other private user data will be removed from the iOS Developer Program（任何开发暗中获取用户密码和私有数据的开发者会被取消IDP身份。）<br>22.8<br>Apps which contain DUI checkpoints that are not published by law enforcement agencies, or encourage and enable drunk driving, will be rejected（任何非法律执行部门发布的带有DUI检查点信息，或鼓励且协助酒后驾车的应用会被拒。）</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;Terms and conditions（法律与条款）&lt;br&gt;1.1&lt;br&gt;As a developer of applications for the App Store you are bound by the terms of the Program Li
    
    </summary>
    
      <category term="Developer" scheme="http://www.jeyblogs.com/categories/Developer/"/>
    
    
      <category term="AppStore" scheme="http://www.jeyblogs.com/tags/AppStore/"/>
    
  </entry>
  
  <entry>
    <title>GitHub 上Top100 的 Objective-C 项目和</title>
    <link href="http://www.jeyblogs.com/2013/11/17/GitHub-%E4%B8%8ATop100-%E7%9A%84-Objective-C-%E9%A1%B9%E7%9B%AE%E5%92%8C/"/>
    <id>http://www.jeyblogs.com/2013/11/17/GitHub-上Top100-的-Objective-C-项目和/</id>
    <published>2013-11-17T02:50:17.000Z</published>
    <updated>2016-08-17T09:07:35.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>AFNetworking<br>作者是 NSHipster 的博主, iOS 开发界的大神级人物, 毕业于卡内基·梅隆大学, 开源了许多牛逼的项目, 这个便是其中之一, AFNetworking 采用 NSURLConnection + NSOperation, 主要方便与服务端 API 进行数据交换, 操作简单, 功能强大, 现在许多人都用它取代 ASIHTTPRequest</li>
<li>GPUImage<br>一款强大的图片滤镜工具, 支持自定义滤镜, 可用来实时处理图片和视频流, 作者是 SonoPlot 公司的 CTO, 在很小的时候便开始接触编程, 他在 SO上面的回答也有很多值得阅读, GPUImage 这个项目从 2012 年开始, 使用 OpenGL 图形程序接口编写, 性能非常好, 现在很多 iOS 程序员都用它来实现 iOS 的模糊效果</li>
<li>SDWebImage<br>作者 Olivier Poitrey 是 Dailymotion 的 CTO, 拥有多个不错的开源项目, 此项目常用于对从 Web 端接受到的图片进行缓存, 是 UIImageView 的扩展, 应用起来比较简单</li>
<li>RestKit<br>主要用于 iOS 上网络通信, 允许与 RESTful Web 服务交互, 常用于处理 API, 解析 JSON, 映射响应对象等操作, 简单易用, 方便你把所有精力都放在对数据的操作上</li>
<li>ReactiveCocoa<br>由 GitHub 工程师们开发的一个应用于 iOS 和 OS X 开发的函数响应式编程新框架, Matt 称其为 “An open source project that exemplifies this brave new era for Objective-C”, 也有人说它是 Cocoa 的未来, 具体可看唐巧写的这篇文章</li>
<li>three20<br>由 Facebook iOS 客户端衍生出的一款 iPhone 框架, 内置许多丰富的功能, 有丰富的界面, 对底层的操作便捷, 为开发者省下了很多时间, 但现在已经停止了更新, 一个 PR 把代码删得干干净净, 不要好奇去点开 Files changed, 我点开后该页面直接卡死, three20 当中的一位作者创建了 Nimbus, 算是 three20 的一个替代品</li>
<li>MBProgressHUD<br>作者 Matej Bukovinski 是一位全栈工程师, UI/UX 设计师, 此项目是一款提示框第三方库, 帮助开发者快速应用到项目中)</li>
<li>MagicalRecord<br>作者是 Coursera 的 iOS 工程师, 该项目创作灵感来自于 Ruby on Rails 的 Active Record, 主要为方便操作 CoreData 而生, 帮助清除 CoreData 引用的代码, 协助方便 CoreData 的工作</li>
<li>FMDB<br>一个对 SQLite 进行封装的库, 使用起来方便, 简单</li>
<li>Mantle<br>作者是 GitHub 的员工, 文档写的很清楚: Mantle makes it easy to write a simple model layer for your Cocoa or Cocoa Touch application, 主要用来将 JSON 数据模型化为 Model 对象, 唱吧在前段时间也改用 Mantle 了.</li>
<li>FlatUIKit<br>收集了很多扁平化 UI 的 iOS 组件, 方便使用</li>
<li>ASIHTTPRequest<br>一个轻量级的 iOS 网络通信类库, 基于 CFNetwork 框架开发, 但现在已经停止更新, 多数开发者改用 AFNetworking 替代)</li>
<li>FastImageCache<br>Path 公司出品的 iOS 库, 作者 Mallory Paine 是苹果前员工, 此类库适用于在滚动时快速显示图像, 高速持久是其最大的特点</li>
<li>Masonry<br>一个轻量级的布局框架, 同时支持 iOS 和 Mac OS X, 语法优雅, 帮助开发者快速适配不同分辨率的 iOS 设备</li>
<li>Shimmer<br>Facebook 推出的一款具有闪烁效果的第三方控件, 供它旗下一款名为 Paper 的应用使用, 安装使用整个过程都十分简单</li>
<li>SVProgressHUD<br>又一款轻量级的 iOS 第三方控件, 用于显示任务加载时的动画, 非常轻便, 容易使用</li>
<li>Slate<br>一款窗口管理应用程序, 但在两年前就已经停止更新了</li>
<li>JSONKit<br>主要用于解析 JSON, 适用于 iOS6 以下环境, 自从 iOS5 开始 Apple 官方给出了 NSJSONSerialization API, 自此大家都用官方的了</li>
<li>Nimbus<br>作者 Jeff 曾为 Facebook, Google 做过不少好东西, 也是 three20 的成员之一, three20 停更后, 他创造出这个框架来代替 three20, 文档齐全</li>
<li>CocoaLumberjack<br>这是 Mac 和 iOS 的一款强大的日志框架, 配置简单, 多线程, 提供更高级的 log 功能, 可用于代替默认的 NSLog 语句</li>
<li>Facebook SDK for iOS<br>Facebook 官方的 iOS SDK, 方便开发者集成 Facebook 的一些功能到自己的 iOS APP 里面</li>
<li>AsyncDisplayKit<br>Facebook 开源的一款 iOS UI 框架, Paper 用的就是该框架, 另外框架还用到了 Facebook 早期开源 Pop 动画引擎</li>
<li>Alcatraz<br>Alcatraz 是一款管理 Xcode 插件、模版以及颜色配置的工具, 可以集成到 Xcode 的图形界面中, 安装删除都是几条命令的事, 很方便, 支持自己开发插件并上传</li>
<li>ViewDeck<br>一款开源的 iOS 活动面板组件, 还原 Path 2.0 的侧滑效果, 作者因为时间关系在两年前停止对其更新</li>
<li>JSQMessagesViewController<br>优雅的 iOS 消息类库, 常用于聊天应用中, 可定制性高</li>
<li>FLEX<br>这是 Flipboard 官方发布的一组专门用于 iOS 开发的应用内调试工具, 开发者无需将其连接到 LLDB/Xcode 或其他远程调试服务器,支持直接在 App 中运行</li>
<li>Xctool<br>是 Facebook 开源的一个命令行工具，用来替代苹果的 XcodeBuild 工具, 极大的方便了 iOS 的构建和测试, 输出错误信息也比较友好, 受到许多 iOS 开发者的称赞, 经常与其搭配使用的还有 OCUnit, Travis CI, OCLint 等测试工具</li>
<li>OpenEmu<br>超强的游戏模拟器, 做游戏开发必备, 官网做得也很不错</li>
<li>iCarousel<br>作者是英国 Charcoal Design 公司的创始人, 开源领域的贡献颇为卓著, 这个项目就是其中之一, 这是一款可以在 iOS 上实现旋转木马视图切换效果的第三方控件, 并提供多种切换效果</li>
<li>RESideMenu<br>作者 Roman Efimov 是雅虎的 iOS 工程师, 这个项目实现了 iOS 上的菜单侧滑效果, 创意来源于 Dribbble, 该项目支持 iOS8<br>321 PNChart<br>作者周楷雯是 90 后, 秒视的创始人, 该项目是一个带动画效果的图表控件, 简约易用, 受到不少开发者喜爱<br>31.2PonyDebugger<br>由 Square 公司推出的一款优秀的 iOS 应用网络调试工具, 用户可以实时看到应用程序的网络请求, 也可以对 iOS 应用程序的核心数据栈进行远程调试</li>
<li>JVFloatLabeledTextField<br>作者是 Thumb Labs 的联合创始人, JVFloatLabeledTextField 是 UITextField 的子类, 主要实现输入框标签浮动效果, 创作灵感来自 Dribbble, 已出现多个移植版本</li>
<li>SWTableViewCell<br>UITableViewCell 的子类, 实现了左右滑动显示信息视图并调出按钮</li>
<li>AwesomeMenu<br>作者是一位中国人, 该项目主要是使用 CoreAnimation 还原了 Path menu 的动画效果</li>
<li>Reachability<br>Reachablity 是用于检测 iOS 设备网络环境的库</li>
<li>VVDocumenter-Xcode<br>作者是王巍国内著名的 iOS 开发者, 人称喵神, 目前在日本 LINE 公司工作, 该项目帮助开发者轻松的生成注释文档, 节省了不少工作量, 赞</li>
<li>The Physical Web<br>由 Chrome 团队主导的一个项目, 意在用 URL 连接世界, 方便用户接受数据, 目前尚处在实验阶段</li>
<li>NewsBlur<br>作者独自一个人 Samuel Clay 做出来的一款名为 NewsBlur 的新闻阅读器, 很多人都称其为 Google Reader 的替代品, 这是它的源码</li>
<li>Cocos2D-SpriteBuilder<br>一个可用于在 iOS, Mac 和 Android 上制作 2D 游戏或其它图形/交互应用的框架, 之前的项目名称为 Cocos Swift, 目前该项目在 GitHub 上更新较为频繁</li>
<li>TTTAttributedLabel<br>UILabel 的替代品, 使 iOS 上的 Label 功能更加丰富, 可支持链接植入等功能</li>
<li>CocoaAsyncSocket<br>一个功能强大、简单易用的异步 socket 通讯类库, 支持 TCP 和 UDP 协议, 可用于 Mac 和 iOS 设备上, 作者 Robbie Hanson 是 Deusty 的首席软件工程师</li>
<li>TapkuLibrary<br>作者是 Devin Ross, 这是在 iOS 上一款功能强大的 UI 效果类库, 可以实现多种酷炫的效果, 目前仍在更新中</li>
<li>Canvas<br>无需编码实现牛逼的动画效果的库, 连设计师都可以快速上手</li>
<li>SocketRocket<br>Square 公司开源的一个 WebSocket 客户端, 稳定并且易用, 做实时应用常会用到, 受广大开发者喜爱</li>
<li>ECSlidingViewController<br>一个视图控制器容器, 将子视图处理成两层, 通过滑动来处理层的切换, 创作灵感来自 Facebook 和 Path的 App, 作者是 Cleveland 的员工</li>
<li>Json Framework<br>用于解析 JSON 数据的一个框架, 但是在 iOS5 以上版本大多数人都选择使用 NSJSONSerialization 来解析 JSON, 该项目现在在 GitHub 上也几乎没怎么更新了</li>
<li>Tweaks<br>Facebook 开源的一款工具, 旨在帮助 iOS 开发者更快的迭代应用, 方便用户动态的调整参数, 是的, Paper 这个项目也用到了</li>
<li>realm-cocoa<br>Realm-Cocoa 是 Realm 公司推出一款移动端数据库, 可以运行在手机、平板和可穿戴设备之上, 其目标是取代 CoreData 和 SQLite 数据库</li>
<li>BlocksKit<br>一个开源的与 Cocoa 紧密集合的基础性框架</li>
<li>Appirater<br>一款用于提醒用户给你的 App 打分的工具</li>
<li>KIF<br>Square 出品的一个开源的用户界面测试框架, 极大的简化了 iOS 开发者的 UI 测试流程</li>
<li>SlackTextViewController<br>Slack 推出的一款具有文字输入框高度自适应, 自动输入, 复制单元格内容等功能的解决方案</li>
<li>JazzHands<br>IFTTT 开源的一个简单易用的关键帧基础动画框架, 可通过手势、scroll views, KVO, ReactiveCocoa 等方式来控制动画</li>
<li>Bolts-iOS<br>Bolts 是一个 Parse 和 Facebook 在内部使用的底层库, 方便移动开发</li>
<li>Spectacle<br>一款易用的 OS X 窗口分屏操作快捷键工具, 这是其源代码</li>
<li>nui<br>方便样式化 iOS 应用中的 UI 元素, 可在短时间内样式化整个应用, 类 CSS 原理</li>
<li>Induction<br>Induction 是一款用于理解数据关系的管理工具, 这是其程序代码</li>
<li>JSONModel<br>一个能迅速解析服务器返回的 Json 数据的库, 方便数据的类型转换</li>
<li>DTCoreText<br>一个开源的 iOS 富文本组件, 它可以解析 HTML 与 CSS 并最终用 CoreText 绘制出来, 通常用于在一些需要显示富文本的场景下代替低性能的 UIWebView</li>
<li>Popping<br>基于 Facebook Pop 引擎的 iOS 动画库, 集合了很多动画效果</li>
<li>TSMessages<br>一个用来弹出显示警告和通知的轻量级库, 样式丰富, 简单易用</li>
<li>KVOController<br>一个简单安全的 KVO(Key-value Observing, 键-值 观察)工具, 提供简单方便、线程安全的API, Facebook 的开源项目之一</li>
<li>MWPhotoBrowser<br>一款简单的 iOS 照片浏览控件</li>
<li>MMDrawerController<br>一个轻量级, 易于使用的侧边抽屉导航 iOS 控件</li>
<li>QuickDialog<br>用于快速创建复杂的 iOS 表单, 自定义了 UITableViewCell, TableView 的样式</li>
<li>SVPullToRefresh<br>一款只需一行代码便可集成上拉刷新和下拉加载的组件</li>
<li>cheddar-ios<br>Cheddar 是一款简单易用的日程管理软件, 这是其早期版本的开源代码, 该项目已停止维护</li>
<li>XVim<br>一款在 Xcode 上实现了 Vim 功能的插件</li>
<li>EGOTableViewPullRefresh<br>一款提供下拉刷新的控件, 最后更新时间是一年前</li>
<li>iOS-boilerplate<br>iOS 应用程序的基础模板, 使用该模板可以省掉许多项目初始编码的工作, 内置非常多丰富的功能, 现已经停止维护</li>
<li>JASidePanels<br>一个 UIViewController 容器, 灵感来自 Facebook 和 Path 2.0 应用的菜单, 实现了左右侧滑的操作</li>
<li>FormatterKit<br>收集了很多构思优秀的 NSFormatter 子类<br>74.MSDynamicsDrawerViewController<br>实现了具有动态弹性效果的抽屉式侧边导航栏, 效果丰富, 可定制性强</li>
<li>idev-recipes<br>iDevRecipes 博客的代码, 演示如何实现一些有趣的控件, 该项目在两年前(2013)停止了更新</li>
<li>XMPPFramework<br>一个基于 RFC-3920 实现, 支持多线程和线程保护, 同时通用于所有的 iOS 和 Mac OS 开发设备的通信框架.</li>
<li>MacGap1<br>一款可以将 HTML/CSS/JS 网络应用打包成原生 Mac App 的工具</li>
<li>FXBlurView<br>iOS 模糊背景类库, 可以方便的根据底层显示的状态生成模糊效果</li>
<li>iOS7-Sampler<br>整合演示了多个具有 iOS7 新特性的的项目, 提供了非常多的例子参考</li>
<li>PromiseKit<br>提供强大的 iOS 开发异步功能, 是 Promises 的实现, 受到广大开发者的追捧</li>
<li>Origami<br>此为 Facebook 推出的 Quartz Composer 的一个开源插件, 由其设计团队花费了 9 个月打造而成, 目的是为方便设计师快速构建原型, 以零代码完成复杂动画的合成和测试, 堪称神器</li>
<li>NSLogger<br>一款强大的日志分析工具, 具有大窗口查看 Log, 自定义日志等级等功能</li>
<li>KSImageNamed-Xcode<br>一款对 UIImage 的 imageNamed 提供自动补全功能的插件, 非常方便</li>
<li>PureLayout<br>一个简单却强大的 AutoLayout API 库, 兼容了 Objective-C 和 Swift, 扩展了 UIView/NSView, NSArray, 和 NSLayoutConstraint</li>
<li>AppleDoc<br>一款 Objective-C 文档生成工具, 生成的文档风格保持与 Apple 官方的一致, 极大的方便了 Xcode 识别自己写的 API 文档, 安装也是十分的简单</li>
<li>iTerm2<br>iTerm2 被不少程序员称赞为 Mac 下最好用的终端, 这是其源代码, 配合 oh-my-zsh 使用效果更佳</li>
<li>Kiwi<br>一个行为驱动开发测试框架, 适用于 iOS 平台, 旨在为开发者提供一个简单配置便可使用的 BDD 库</li>
<li>terminal-notifier<br>一款命令行工具, 用来给 Mac OS X 用户发送通知</li>
<li>MacDown<br>Mac OS X 下的一款开源的 Markdown 编辑器, 创意来自与 Mou, 使用 brew cask 即可完成安装</li>
<li>TwUI<br>Twitter 开源的一个支持硬件加速的 Mac 的 UI 框架, 最后一次的更新时间是在 3 年前(2012)</li>
<li>PaperFold for iOS<br>实现了类似折纸效果的视图切换, 可从不同方向进行切换, 该项目已经许久未更新</li>
<li>Reader<br>一款开源的 iOS PDF 阅读器, 附带书签, 列纲要等功能</li>
<li>WebViewJavascriptBridge<br>一个方便使用 Objective-C 与 JavaScript 进行通信的第三方库, 支持消息发送, 接收, 消息处理器的注册与调用以及设置消息处理的回调</li>
<li>iOS8-Sampler<br>iOSX-Sampler 系列之一, 整合演示了多个具有 iOS8 新特性的的项目, 提供了非常多的例子参考</li>
<li>CocoaHTTPServer<br>一个用于 Mac OS X 或 iOS 应用的轻量级、可嵌入的HTTP 服务器框架, 方便开发者在应用中嵌入一个 HTTP 服务器</li>
<li>Kod<br>Mac OS X 上一款专为程序员打造的编辑器, 这是其开源代码, 可惜的是作者在 2011 年停止了维护</li>
<li>TPKeyboardAvoiding<br>下拉键盘在 iOS 移动文本字段的通用解决方案, 能够自动处理键盘弹出后出现遮挡到文本输入框的问题</li>
<li>MKNetworkKit<br>一个轻量级网络请求框架, 完全基于 ARC, 仅有两个类, 具有自主操作多个网络请求, 更加准确的显示网络活动指标等优点</li>
<li>PKRevealController<br>一个 iOS 平台上的视图控制器集合, 通过展现多个视图控制器来进行控制器之间的切换. 设置简单, 高度灵活</li>
<li>AQGridView<br>一个命令行工具, 通过项目里的 .xcdatamodel 文件, 可以为每个 entity 生成两个类, 方便 CoreData 的使用</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;AFNetworking&lt;br&gt;作者是 NSHipster 的博主, iOS 开发界的大神级人物, 毕业于卡内基·梅隆大学, 开源了许多牛逼的项目, 这个便是其中之一, AFNetworking 采用 NSURLConnection + NSOperation,
    
    </summary>
    
      <category term="Developer" scheme="http://www.jeyblogs.com/categories/Developer/"/>
    
    
      <category term="第三方资源" scheme="http://www.jeyblogs.com/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>超全面！常用的 iOS 第三方资源</title>
    <link href="http://www.jeyblogs.com/2013/11/15/%E8%B6%85%E5%85%A8%E9%9D%A2%EF%BC%81%E5%B8%B8%E7%94%A8%E7%9A%84%20iOS%20%E7%AC%AC%E4%B8%89%E6%96%B9%E8%B5%84%E6%BA%90/"/>
    <id>http://www.jeyblogs.com/2013/11/15/超全面！常用的 iOS 第三方资源/</id>
    <published>2013-11-15T02:29:49.000Z</published>
    <updated>2016-08-17T09:07:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>一：第三方插件<br>1:基于响应式编程思想的oc<br>地址：<a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="external">https://github.com/ReactiveCocoa/ReactiveCocoa</a><br>2：hud提示框<br>地址：<a href="https://github.com/jdg/MBProgressHUD" target="_blank" rel="external">https://github.com/jdg/MBProgressHUD</a><br>3：XML/HTML解析<br>地址：<a href="https://github.com/topfunky/hpple" target="_blank" rel="external">https://github.com/topfunky/hpple</a><br>4：有文字输入时，能根据键盘是否弹出来调整自身显示内容的位置<br>地址：<a href="https://github.com/michaeltyson/TPKeyboardAvoiding" target="_blank" rel="external">https://github.com/michaeltyson/TPKeyboardAvoiding</a><br>5：状态栏提示框<br>地址：<a href="https://github.com/jaydee3/JDStatusBarNotification" target="_blank" rel="external">https://github.com/jaydee3/JDStatusBarNotification</a><br>6：block工具包。将很多需要用delegate实现的方法整合成了block的形式<br>地址：<a href="https://github.com/zwaldowski/BlocksKit" target="_blank" rel="external">https://github.com/zwaldowski/BlocksKit</a><br>7：图片加载<br>地址：<a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">https://github.com/rs/SDWebImage</a><br>8：正则表达式<br>地址：<a href="https://github.com/wezm/RegexKitLite" target="_blank" rel="external">https://github.com/wezm/RegexKitLite</a><br>9：Masonry代码布局<br>地址：<a href="https://github.com/SnapKit/Masonry" target="_blank" rel="external">https://github.com/SnapKit/Masonry</a><br>10：弹出窗<br>地址：<a href="https://github.com/sberrevoets/SDCAlertView" target="_blank" rel="external">https://github.com/sberrevoets/SDCAlertView</a><br>11:Button的样式<br>地址：<a href="https://github.com/mattlawer/BButton" target="_blank" rel="external">https://github.com/mattlawer/BButton</a><br>12：验证网络连接状态<br>地址：<a href="https://github.com/tonymillion/Reachability" target="_blank" rel="external">https://github.com/tonymillion/Reachability</a><br>13：自动计算表格行高<br>地址：<a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell" target="_blank" rel="external">https://github.com/forkingdog/UITableView-FDTemplateLayoutCell</a><br>14：动画效果的启动页<br>地址：<a href="https://github.com/IFTTT/JazzHands" target="_blank" rel="external">https://github.com/IFTTT/JazzHands</a><br>15：iOS快速简单集成国内三大平台分享<br>地址：<a href="https://github.com/xumeng/XMShareModule" target="_blank" rel="external">https://github.com/xumeng/XMShareModule</a><br>16：五项能力值展示的五边形<br>地址：<a href="https://github.com/dsxNiubility/SXFiveScoreShow" target="_blank" rel="external">https://github.com/dsxNiubility/SXFiveScoreShow</a><br>17：自动识别网址号码邮箱和表情的label<br>地址：<a href="https://github.com/molon/MLEmojiLabel" target="_blank" rel="external">https://github.com/molon/MLEmojiLabel</a><br>18：IM对话功能的封装<br>地址：<a href="https://github.com/ZhipingYang/UUChatTableView" target="_blank" rel="external">https://github.com/ZhipingYang/UUChatTableView</a><br>19：字典转模型框架<br>地址：<a href="https://github.com/CoderMJLee/MJExtension" target="_blank" rel="external">https://github.com/CoderMJLee/MJExtension</a><br>20：下拉上拉刷数据<br>地址：<a href="https://github.com/CoderMJLee/MJRefresh" target="_blank" rel="external">https://github.com/CoderMJLee/MJRefresh</a><br>21：表格行左右划动菜单<br>地址：<a href="https://github.com/MortimerGoro/MGSwipeTableCell" target="_blank" rel="external">https://github.com/MortimerGoro/MGSwipeTableCell</a><br>22:图文混搭<br>地址:<a href="https://github.com/zhouande/TLAttributedLabel" target="_blank" rel="external">https://github.com/zhouande/TLAttributedLabel</a><br>23:可以简单展示在UINavigationBar下方，类似Music app的播放列表视图，弹出菜单视图<br>地址：<a href="https://github.com/DrummerB/BFNavigationBarDrawer" target="_blank" rel="external">https://github.com/DrummerB/BFNavigationBarDrawer</a><br>24：比如筛选、模糊、优化、蒙版、调整大小、旋转以及保存等等。同时还提供了一个UIImageView子类从URL异步加载图片，并在下载完毕时展示图片。<br>地址：<a href="https://github.com/Nyx0uf/NYXImagesKit" target="_blank" rel="external">https://github.com/Nyx0uf/NYXImagesKit</a><br>25：底部TabBar<br>地址：<a href="https://github.com/robbdimitrov/RDVTabBarController" target="_blank" rel="external">https://github.com/robbdimitrov/RDVTabBarController</a><br>26:表情面版<br>地址：<a href="https://github.com/ayushgoel/AGEmojiKeyboard" target="_blank" rel="external">https://github.com/ayushgoel/AGEmojiKeyboard</a><br>27:记录框架<br>地址：<a href="https://github.com/CocoaLumberjack/CocoaLumberjack" target="_blank" rel="external">https://github.com/CocoaLumberjack/CocoaLumberjack</a><br>28：IOS与javascript交互<br>地址：<a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="external">https://github.com/marcuswestin/WebViewJavascriptBridge</a><br>29：图表统计展示<br>地址：<a href="https://github.com/kevinzhow/PNChart" target="_blank" rel="external">https://github.com/kevinzhow/PNChart</a><br>30:appStore评分<br>地址：<a href="https://github.com/arashpayan/appirater" target="_blank" rel="external">https://github.com/arashpayan/appirater</a><br>31：iOS-Categories 扩展类大全<br>地址：<a href="https://github.com/shaojiankui/IOS-Categories" target="_blank" rel="external">https://github.com/shaojiankui/IOS-Categories</a><br>32：扫描二维码，仿微信效果，带有扫描条<br>地址：<a href="https://github.com/JxbSir/JxbScanQR" target="_blank" rel="external">https://github.com/JxbSir/JxbScanQR</a><br>33:动效弹出视图(弹出窗里面为文字，可以定义弹出的方向，及显示的时间)–AMPopTip<br>地址：<a href="https://github.com/andreamazz/AMPopTip" target="_blank" rel="external">https://github.com/andreamazz/AMPopTip</a><br>34:基于Masonry自动计算行高扩展<br>地址：<a href="https://github.com/632840804/HYBMasonryAutoCellHeight" target="_blank" rel="external">https://github.com/632840804/HYBMasonryAutoCellHeight</a><br>35:模仿新浪微博弹出菜单<br>地址：<a href="https://github.com/wwdc14/HyPopMenuView" target="_blank" rel="external">https://github.com/wwdc14/HyPopMenuView</a><br>36:搜索历史标签<br>地址：<a href="https://github.com/zhiwupei/SearchHistory" target="_blank" rel="external">https://github.com/zhiwupei/SearchHistory</a><br>37：快速集成新手引导的类库<br>地址：<a href="https://github.com/StrongX/XSportLight" target="_blank" rel="external">https://github.com/StrongX/XSportLight</a><br>38：设置页面的封装<br>地址：<a href="https://github.com/renzifeng/ZFSetting" target="_blank" rel="external">https://github.com/renzifeng/ZFSetting</a><br>39：带箭头的弹出视图插件<br>地址：<a href="https://github.com/xiekw2010/DXPopover" target="_blank" rel="external">https://github.com/xiekw2010/DXPopover</a><br>40：下拉菜单插件<br>地址：<a href="https://github.com/dopcn/DOPDropDownMenu/" target="_blank" rel="external">https://github.com/dopcn/DOPDropDownMenu/</a><br>41：表格空白提示插件<br>地址：<a href="https://github.com/dzenbot/DZNEmptyDataSet" target="_blank" rel="external">https://github.com/dzenbot/DZNEmptyDataSet</a><br>42:给任意UIView视图四条边框加上阴影，可以自定义阴影的颜色、粗细程度、透明程度以及位置（上下左右边框）<br>地址：<a href="https://github.com/Seitk/UIView-Shadow-Maker" target="_blank" rel="external">https://github.com/Seitk/UIView-Shadow-Maker</a><br>43:不错的日期时间插件<br>地址：<a href="https://github.com/CoderXL/UUDatePicker" target="_blank" rel="external">https://github.com/CoderXL/UUDatePicker</a><br>44:底部弹出选择<br>地址：<a href="https://github.com/skywinder/ActionSheetPicker-3.0" target="_blank" rel="external">https://github.com/skywinder/ActionSheetPicker-3.0</a><br>45:比较不错的引导页面插件<br>地址：<a href="https://github.com/ealeksandrov/EAIntroView" target="_blank" rel="external">https://github.com/ealeksandrov/EAIntroView</a><br>46:两个APP跳转的插件<br>地址：<a href="https://github.com/usebutton/DeepLinkKit" target="_blank" rel="external">https://github.com/usebutton/DeepLinkKit</a><br>47:本地存取NSUserDefaults插件<br>地址：<a href="https://github.com/gangverk/GVUserDefaults" target="_blank" rel="external">https://github.com/gangverk/GVUserDefaults</a><br>48:NSArray 和 NSDictionary关于LINQ的操作方式，封装一些常用的操作<br>地址：<a href="https://github.com/ColinEberhardt/LinqToObjectiveC" target="_blank" rel="external">https://github.com/ColinEberhardt/LinqToObjectiveC</a><br>49:可以监控网络请求的内容<br>地址：<a href="https://github.com/coderyi/NetworkEye" target="_blank" rel="external">https://github.com/coderyi/NetworkEye</a><br>50：时间帮助插件，可以快速获取时间，比较，增加等操作<br>地址：<a href="https://github.com/MatthewYork/DateTools" target="_blank" rel="external">https://github.com/MatthewYork/DateTools</a><br>51: 不错的链式动作<br>地址：<a href="https://github.com/jhurray/JHChainableAnimations" target="_blank" rel="external">https://github.com/jhurray/JHChainableAnimations</a><br>52:弹出层视图，背景效果（可以自定义视图的内容）<br>地址：<a href="https://github.com/HJaycee/JCAlertView" target="_blank" rel="external">https://github.com/HJaycee/JCAlertView</a><br>53:圆形进度条的显示，中间可显示值<br>地址：<a href="https://github.com/mdinacci/MDRadialProgress" target="_blank" rel="external">https://github.com/mdinacci/MDRadialProgress</a><br>54:很帅的数据加载动画（可以用于数据列表加载的展现）<br>地址：<a href="https://github.com/NghiaTranUIT/FeSpinner" target="_blank" rel="external">https://github.com/NghiaTranUIT/FeSpinner</a><br>55:一个开源的AFnetworking上层的封装（猿题库等运用）<br>地址：<a href="https://github.com/yuantiku/YTKNetwork" target="_blank" rel="external">https://github.com/yuantiku/YTKNetwork</a><br>56:CBStoreHouseRefreshControl：一个效果很酷炫的下拉刷新控件<br>地址：<a href="https://github.com/coolbeet/CBStoreHouseRefreshControl" target="_blank" rel="external">https://github.com/coolbeet/CBStoreHouseRefreshControl</a><br>57:AFNetworking-RACExtensions:针对ReactiveCocoa的AF封装<br>地址：<a href="https://github.com/CodaFi/AFNetworking-RACExtensions" target="_blank" rel="external">https://github.com/CodaFi/AFNetworking-RACExtensions</a><br>58:模糊效果（毛玻璃）<br>地址：<a href="https://github.com/nicklockwood/FXBlurView" target="_blank" rel="external">https://github.com/nicklockwood/FXBlurView</a><br>二：源代码实例<br>1:Coding.net客户端<br>地址：<a href="https://coding.net/u/coding/p/Coding-iOS/git" target="_blank" rel="external">https://coding.net/u/coding/p/Coding-iOS/git</a><br>2:高仿美团iOS版<br>地址：<a href="https://github.com/lookingstars/meituan" target="_blank" rel="external">https://github.com/lookingstars/meituan</a><br>3:模仿网易新闻做的精仿网易新闻<br>地址：<a href="https://github.com/dsxNiubility/SXNews" target="_blank" rel="external">https://github.com/dsxNiubility/SXNews</a><br>4:支付宝高仿版<br>地址：<a href="https://github.com/gsdios/GSD_ZHIFUBAO" target="_blank" rel="external">https://github.com/gsdios/GSD_ZHIFUBAO</a><br>5:高仿百度传课iOS版<br>地址：<a href="https://github.com/lookingstars/chuanke" target="_blank" rel="external">https://github.com/lookingstars/chuanke</a><br>6：模仿一元云购<br>地址：<a href="https://github.com/JxbSir/YiYuanYunGou" target="_blank" rel="external">https://github.com/JxbSir/YiYuanYunGou</a><br>7：wordpress源代码<br>地址：<a href="https://github.com/wordpress-mobile/WordPress-iOS" target="_blank" rel="external">https://github.com/wordpress-mobile/WordPress-iOS</a><br>8：v2ex源代码（文章类型，若报SVProgressHUD错，则把Podfile中的SVProgressHUD移除）<br>地址：<a href="https://github.com/singro/v2ex" target="_blank" rel="external">https://github.com/singro/v2ex</a><br>9:PHPHub客户端(IOS8.0以上)<br>地址：<a href="https://github.com/Aufree/phphub-ios" target="_blank" rel="external">https://github.com/Aufree/phphub-ios</a><br>10:快速搭建项目源代码<br>地址：<a href="https://github.com/wujunyang/MobileProject" target="_blank" rel="external">https://github.com/wujunyang/MobileProject</a><br>三：辅助软件<br>1：XCODE文档注解插件VVDocumenter<br>地址：<a href="https://github.com/onevcat/VVDocumenter-Xcode" target="_blank" rel="external">https://github.com/onevcat/VVDocumenter-Xcode</a><br>2：将JSON格式化输出为模型的属性<br>地址：<a href="https://github.com/EnjoySR/ESJsonFormat-Xcode" target="_blank" rel="external">https://github.com/EnjoySR/ESJsonFormat-Xcode</a><br>3：图片提示插件<br>地址：<a href="https://github.com/ksuther/KSImageNamed-Xcode" target="_blank" rel="external">https://github.com/ksuther/KSImageNamed-Xcode</a><br>4：图片转换插件<br>地址：<a href="https://github.com/rickytan/RTImageAssets" target="_blank" rel="external">https://github.com/rickytan/RTImageAssets</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一：第三方插件&lt;br&gt;1:基于响应式编程思想的oc&lt;br&gt;地址：&lt;a href=&quot;https://github.com/ReactiveCocoa/ReactiveCocoa&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.co
    
    </summary>
    
      <category term="Developer" scheme="http://www.jeyblogs.com/categories/Developer/"/>
    
    
      <category term="第三方资源" scheme="http://www.jeyblogs.com/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>Object-C——iOS开发编码规范</title>
    <link href="http://www.jeyblogs.com/2013/10/18/Object-C%E2%80%94%E2%80%94iOS%E5%BC%80%E5%8F%91%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>http://www.jeyblogs.com/2013/10/18/Object-C——iOS开发编码规范/</id>
    <published>2013-10-18T03:41:32.000Z</published>
    <updated>2016-08-17T09:07:35.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><p>任意函数长度不得超过50行。</p>
</li>
<li><p>每一行行代码不能超过80个字符。设置提醒：可以在Xcode中设置超过80个字符的提醒，Preferences—Text Editing—Page guide at column勾上.设置完之后就会在代码80个字符处有一条竖线。</p>
</li>
<li><p>方法的“+”，“-”与括号之间留空格</p>
</li>
<li><p>在方法和方法之间留空一行。</p>
</li>
<li><p>功能相近的方法要放在一起，并推荐使用#pragma mark - <strong> </strong>来标注，在代码导航栏可以快速查找</p>
</li>
<li><p>二元运算符和参数之间要有一个空格，如赋值号 = 左右各留一个空格。<br>self.myString = @”235423rew523452345”;</p>
</li>
<li><p>一元运算符和参数之间不放置空格，比如！非运算符，&amp;按位与，|按位或。<br>BOOL isOpen = true;<br>BOOL isClose = !isOpen;</p>
</li>
<li><p>强制类型转换和参数之间不放置空格。<br>NSString <em>str3 = (NSString</em>)self.myString;</p>
</li>
<li><p>长的变量值应该拆分为多行。尤其体现在使用数组或者字典。以下也分别是快速声明数组@[]和字典@{}的方法。<br>NSArray *array = @[@”111”,</p>
<pre><code>@&quot;2222222222&quot;,
@&quot;3333333&quot;,
@&quot;wwwwwwwwwwww&quot;
];
</code></pre><p>NSDictionary *dict = @{@”name”:@”jack”,</p>
<pre><code>@&quot;age&quot;:@&quot;20&quot;,
@&quot;gender&quot;:@&quot;female&quot;,
@&quot;isMarried&quot;:@&quot;false&quot;
};
</code></pre></li>
<li><p>使用有意义的名字命名，拒绝使用i,j等无意义字符命名。类的命名首字母大写，其他变量的命名首字符小写，并使用驼峰式分割单词。</p>
</li>
<li><p>尽量减少在代码中直接使用数字常量，而使用宏定义等方式。如：MAX_NUMBER_PHONE替代8等等。</p>
</li>
<li><p>尽量减少代码中的重复计算，比如代码中多处要使用屏幕宽度，然后计算：[[UIScreenmainScreen] bounds].size.width ,很多次，闲得很繁琐，代码也冗长。不如直接宏定义：<br>#define SCREEN_WIDTH ([[UIScreen mainScreen] bounds].size.width)<br>宏定义全部字母大写</p>
</li>
<li><p>合理使用约定俗成的缩略词：</p>
<pre><code>alloc:分配；
alt：轮流，交替；
app:应用程序；
calc：计算；
dealloc：销毁、析构；
func：函数、方法；
horiz：水平的；
info：信息；
init：初始化；
max：最大的；
min：最小的；
msg：消息；
nib：Interface Builder；
rect：矩形；
temp：暂时的；
vert：垂直的；
</code></pre></li>
<li><p>合理范围内使用链式编程:<br>NSString *myName = [[NSString alloc] init];<br>但是嵌套不宜超过3层，超过3层需进行重构。</p>
</li>
<li><p>函数调用时所有参数在同一行。如果参数过多，则可以每行一个参数，每个参数以冒号对齐。</p>
</li>
<li><p>对传入参数的保护或者说是否为空的判断，尽量不要使用if(!obj),而使用NSAssert断言来处理。NSAssert是系统定义的宏。<br>NSAssert(myName != nil, @”myName参数为空”);</p>
<pre><code>如果条件判断为真，则程序继续执行；
如果判断条件为假，则抛出异常，异常内容为后面定义的字符串；
</code></pre></li>
<li><p>if-else超过四层的时候，就要考虑重构，多层的if-else结构很难维护。</p>
</li>
<li><p>当需要一定条件才执行某项操作时，最左边的应该是最重要的代码，不要将最重要的代码内嵌到if中。<br>如良好的风格是：</p>
</li>
</ol>
<ul>
<li>(void) someMethod {if(![someOther boolValue]) {   return;<br>}//最重要的代码写在这里；}<br>  反面教材:</li>
<li>(void) someMethod {if([someOther boolValue]) {<br>  //重要代码；<br>}<br>}</li>
</ul>
<ol>
<li><p>所有的逻辑块都使用{}花括号包围，就算只是一行代码。</p>
</li>
<li><p>明确指定构造函数，并且加上注释的注释，加上注释，加上注释！</p>
</li>
<li><p>UIView的子类初始化的时候，不要进行任何的布局操作。布局操作应该在layoutSubviews里面做；需要重新布局的时候调用setNeedsLayout，而不要直接调用layoutSubviews。</p>
</li>
<li><p>保持公共API简单，也就是保持.h文件简单。放在.h中声明的函数都是会被公开的，如果根本就没必要对其他类公开，再不要在.h中声明。OC中的方法都是公有方法，没有私有方法一说。</p>
</li>
<li><p>一个文件只实现一个类。同一个文件中不要有多个类。</p>
</li>
<li><p>Protocol单独用一个文件来创建，尽量不要与相关类混在一个文件中。</p>
</li>
<li><p>布局时尽量使用相对布局，比如使用子View在父View中的相对位置。</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;任意函数长度不得超过50行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每一行行代码不能超过80个字符。设置提醒：可以在Xcode中设置超过80个字符的提醒，Preferences—Text Editing—Page guide at column勾上.设置完之后
    
    </summary>
    
      <category term="Developer" scheme="http://www.jeyblogs.com/categories/Developer/"/>
    
    
      <category term="iOS编码规范" scheme="http://www.jeyblogs.com/tags/iOS%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title> iOS常用宏定义</title>
    <link href="http://www.jeyblogs.com/2013/09/30/iOS%E5%B8%B8%E7%94%A8%E5%AE%8F%E5%AE%9A%E4%B9%89/"/>
    <id>http://www.jeyblogs.com/2013/09/30/iOS常用宏定义/</id>
    <published>2013-09-30T06:54:44.000Z</published>
    <updated>2016-08-30T09:45:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="iOS常用宏定义"><a href="#iOS常用宏定义" class="headerlink" title="iOS常用宏定义"></a>iOS常用宏定义</h3><h1 id="ifndef-MacroDefinition-h"><a href="#ifndef-MacroDefinition-h" class="headerlink" title="ifndef MacroDefinition_h"></a>ifndef MacroDefinition_h</h1><h1 id="define-MacroDefinition-h"><a href="#define-MacroDefinition-h" class="headerlink" title="define MacroDefinition_h"></a>define MacroDefinition_h</h1><p>//——————-获取设备大小————————-<br>//NavBar高度</p>
<h1 id="define-NavigationBar-HEIGHT-44"><a href="#define-NavigationBar-HEIGHT-44" class="headerlink" title="define NavigationBar_HEIGHT 44"></a>define NavigationBar_HEIGHT 44</h1><p>//获取屏幕 宽度、高度</p>
<h1 id="define-SCREEN-WIDTH-UIScreen-mainScreen-bounds-size-width"><a href="#define-SCREEN-WIDTH-UIScreen-mainScreen-bounds-size-width" class="headerlink" title="define SCREEN_WIDTH ([UIScreen mainScreen].bounds.size.width)"></a>define SCREEN_WIDTH ([UIScreen mainScreen].bounds.size.width)</h1><h1 id="define-SCREEN-HEIGHT-UIScreen-mainScreen-bounds-size-height"><a href="#define-SCREEN-HEIGHT-UIScreen-mainScreen-bounds-size-height" class="headerlink" title="define SCREEN_HEIGHT ([UIScreen mainScreen].bounds.size.height)"></a>define SCREEN_HEIGHT ([UIScreen mainScreen].bounds.size.height)</h1><p>// MainScreen bounds</p>
<h1 id="define-Main-Screen-Bounds-UIScreen-mainScreen-bounds"><a href="#define-Main-Screen-Bounds-UIScreen-mainScreen-bounds" class="headerlink" title="define Main_Screen_Bounds [[UIScreen mainScreen] bounds]"></a>define Main_Screen_Bounds [[UIScreen mainScreen] bounds]</h1><p>//——————-获取设备大小————————-</p>
<p>//——————-打印日志————————-<br>//DEBUG 模式下打印日志,当前行</p>
<h1 id="ifdef-DEBUG"><a href="#ifdef-DEBUG" class="headerlink" title="ifdef DEBUG"></a>ifdef DEBUG</h1><h1 id="define-DLog-fmt-…-NSLog-”-s-Line-d-“-fmt-PRETTY-FUNCTION-LINE-VA-ARGS"><a href="#define-DLog-fmt-…-NSLog-”-s-Line-d-“-fmt-PRETTY-FUNCTION-LINE-VA-ARGS" class="headerlink" title="define DLog(fmt, …) NSLog((@”%s [Line %d] “ fmt), PRETTY_FUNCTION, LINE, ##VA_ARGS);"></a>define DLog(fmt, …) NSLog((@”%s [Line %d] “ fmt), <strong>PRETTY_FUNCTION</strong>, <strong>LINE</strong>, ##<strong>VA_ARGS</strong>);</h1><h1 id="else"><a href="#else" class="headerlink" title="else"></a>else</h1><h1 id="define-DLog-…"><a href="#define-DLog-…" class="headerlink" title="define DLog(…)"></a>define DLog(…)</h1><h1 id="endif"><a href="#endif" class="headerlink" title="endif"></a>endif</h1><p>//重写NSLog,Debug模式下打印日志和当前行数</p>
<h1 id="if-DEBUG"><a href="#if-DEBUG" class="headerlink" title="if DEBUG"></a>if DEBUG</h1><h1 id="define-NSLog-FORMAT-…-fprintf-stderr-”-nfunction-s-line-d-content-s-n”-FUNCTION-LINE-［NSString-stringWithFormat-FORMAT-VA-ARGS-UTF8String"><a href="#define-NSLog-FORMAT-…-fprintf-stderr-”-nfunction-s-line-d-content-s-n”-FUNCTION-LINE-［NSString-stringWithFormat-FORMAT-VA-ARGS-UTF8String" class="headerlink" title="define NSLog(FORMAT, …) fprintf(stderr,”\nfunction:%s line:%d content:%s\n”, FUNCTION, LINE, ［NSString stringWithFormat:FORMAT, ##VA_ARGS] UTF8String]);"></a>define NSLog(FORMAT, …) fprintf(stderr,”\nfunction:%s line:%d content:%s\n”, <strong>FUNCTION</strong>, <strong>LINE</strong>, ［NSString stringWithFormat:FORMAT, ##<strong>VA_ARGS</strong>] UTF8String]);</h1><h1 id="else-1"><a href="#else-1" class="headerlink" title="else"></a>else</h1><h1 id="define-NSLog-FORMAT-…-nil"><a href="#define-NSLog-FORMAT-…-nil" class="headerlink" title="define NSLog(FORMAT, …) nil"></a>define NSLog(FORMAT, …) nil</h1><h1 id="endif-1"><a href="#endif-1" class="headerlink" title="endif"></a>endif</h1><p>//DEBUG 模式下打印日志,当前行 并弹出一个警告</p>
<h1 id="ifdef-DEBUG-1"><a href="#ifdef-DEBUG-1" class="headerlink" title="ifdef DEBUG"></a>ifdef DEBUG</h1><h1 id="define-ULog-fmt-…-UIAlertView-alert-［UIAlertView-alloc-initWithTitle-NSString-stringWithFormat-”-s-n-Line-d-“-PRETTY-FUNCTION-LINE-message-NSString-stringWithFormat-fmt-VA-ARGS-delegate-nil-cancelButtonTitle-”Ok”-otherButtonTitles-nil-alert-show"><a href="#define-ULog-fmt-…-UIAlertView-alert-［UIAlertView-alloc-initWithTitle-NSString-stringWithFormat-”-s-n-Line-d-“-PRETTY-FUNCTION-LINE-message-NSString-stringWithFormat-fmt-VA-ARGS-delegate-nil-cancelButtonTitle-”Ok”-otherButtonTitles-nil-alert-show" class="headerlink" title="define ULog(fmt, …) { UIAlertView *alert = ［UIAlertView alloc] initWithTitle:[NSString stringWithFormat:@”%s\n [Line %d] “, PRETTY_FUNCTION, LINE] message:[NSString stringWithFormat:fmt, ##VA_ARGS] delegate:nil cancelButtonTitle:@”Ok” otherButtonTitles:nil]; [alert show]; }"></a>define ULog(fmt, …) { UIAlertView *alert = ［UIAlertView alloc] initWithTitle:[NSString stringWithFormat:@”%s\n [Line %d] “, <strong>PRETTY_FUNCTION</strong>, <strong>LINE</strong>] message:[NSString stringWithFormat:fmt, ##<strong>VA_ARGS</strong>] delegate:nil cancelButtonTitle:@”Ok” otherButtonTitles:nil]; [alert show]; }</h1><h1 id="else-2"><a href="#else-2" class="headerlink" title="else"></a>else</h1><h1 id="define-ULog-…"><a href="#define-ULog-…" class="headerlink" title="define ULog(…)"></a>define ULog(…)</h1><h1 id="endif-2"><a href="#endif-2" class="headerlink" title="endif"></a>endif</h1><p>//打印Frame</p>
<h1 id="define-LogFrame-frame-NSLog-”frame-X-1f-Y-1f-W-1f-H-1f”-frame-origin-x-frame-origin-y-frame-size-width-frame-size-height"><a href="#define-LogFrame-frame-NSLog-”frame-X-1f-Y-1f-W-1f-H-1f”-frame-origin-x-frame-origin-y-frame-size-width-frame-size-height" class="headerlink" title="define LogFrame(frame) NSLog(@”frame[X=%.1f,Y=%.1f,W=%.1f,H=%.1f”,frame.origin.x,frame.origin.y,frame.size.width,frame.size.height)"></a>define LogFrame(frame) NSLog(@”frame[X=%.1f,Y=%.1f,W=%.1f,H=%.1f”,frame.origin.x,frame.origin.y,frame.size.width,frame.size.height)</h1><p>//打印Point</p>
<h1 id="define-LogPoint-point-NSLog-”Point-X-1f-Y-1f-”-point-x-point-y"><a href="#define-LogPoint-point-NSLog-”Point-X-1f-Y-1f-”-point-x-point-y" class="headerlink" title="define LogPoint(point) NSLog(@”Point[X=%.1f,Y=%.1f]”,point.x,point.y)"></a>define LogPoint(point) NSLog(@”Point[X=%.1f,Y=%.1f]”,point.x,point.y)</h1><p>//———————————————–<br>// 字体大小(常规/粗体)</p>
<h1 id="define-BOLDSYSTEMFONT-FONTSIZE-UIFont-boldSystemFontOfSize-FONTSIZE"><a href="#define-BOLDSYSTEMFONT-FONTSIZE-UIFont-boldSystemFontOfSize-FONTSIZE" class="headerlink" title="define BOLDSYSTEMFONT(FONTSIZE)[UIFont boldSystemFontOfSize:FONTSIZE]"></a>define BOLDSYSTEMFONT(FONTSIZE)[UIFont boldSystemFontOfSize:FONTSIZE]</h1><h1 id="define-SYSTEMFONT-FONTSIZE-UIFont-systemFontOfSize-FONTSIZE"><a href="#define-SYSTEMFONT-FONTSIZE-UIFont-systemFontOfSize-FONTSIZE" class="headerlink" title="define SYSTEMFONT(FONTSIZE)    [UIFont systemFontOfSize:FONTSIZE]"></a>define SYSTEMFONT(FONTSIZE)    [UIFont systemFontOfSize:FONTSIZE]</h1><h1 id="define-FONT-NAME-FONTSIZE-UIFont-fontWithName-NAME-size-FONTSIZE"><a href="#define-FONT-NAME-FONTSIZE-UIFont-fontWithName-NAME-size-FONTSIZE" class="headerlink" title="define FONT(NAME, FONTSIZE)    [UIFont fontWithName:(NAME) size:(FONTSIZE)]"></a>define FONT(NAME, FONTSIZE)    [UIFont fontWithName:(NAME) size:(FONTSIZE)]</h1><p>//———————-系统—————————-</p>
<p>// 是否iPad</p>
<h1 id="define-isPad-UI-USER-INTERFACE-IDIOM-UIUserInterfaceIdiomPad"><a href="#define-isPad-UI-USER-INTERFACE-IDIOM-UIUserInterfaceIdiomPad" class="headerlink" title="define isPad (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad)"></a>define isPad (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad)</h1><p>// 是否iPad</p>
<h1 id="define-someThing-UI-USER-INTERFACE-IDIOM-UIUserInterfaceIdiomPad-ipad-iphone"><a href="#define-someThing-UI-USER-INTERFACE-IDIOM-UIUserInterfaceIdiomPad-ipad-iphone" class="headerlink" title="define someThing (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad)? ipad: iphone"></a>define someThing (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad)? ipad: iphone</h1><p>//获取系统版本</p>
<h1 id="define-IOS-VERSION-［-UIDevice-currentDevice-systemVersion-floatValue"><a href="#define-IOS-VERSION-［-UIDevice-currentDevice-systemVersion-floatValue" class="headerlink" title="define IOS_VERSION ［[UIDevice currentDevice] systemVersion] floatValue]"></a>define IOS_VERSION ［[UIDevice currentDevice] systemVersion] floatValue]</h1><h1 id="define-CurrentSystemVersion-［UIDevice-currentDevice-systemVersion"><a href="#define-CurrentSystemVersion-［UIDevice-currentDevice-systemVersion" class="headerlink" title="define CurrentSystemVersion ［UIDevice currentDevice] systemVersion]"></a>define CurrentSystemVersion ［UIDevice currentDevice] systemVersion]</h1><p>//App版本号</p>
<h1 id="define-appMPVersion-NSBundle-mainBundle-infoDictionary-objectForKey-”CFBundleShortVersionString”"><a href="#define-appMPVersion-NSBundle-mainBundle-infoDictionary-objectForKey-”CFBundleShortVersionString”" class="headerlink" title="define appMPVersion [[[NSBundle mainBundle] infoDictionary] objectForKey:@”CFBundleShortVersionString”]"></a>define appMPVersion [[[NSBundle mainBundle] infoDictionary] objectForKey:@”CFBundleShortVersionString”]</h1><p>//获取当前语言</p>
<h1 id="define-CurrentLanguage-［NSLocale-preferredLanguages-objectAtIndex-0"><a href="#define-CurrentLanguage-［NSLocale-preferredLanguages-objectAtIndex-0" class="headerlink" title="define CurrentLanguage (［NSLocale preferredLanguages] objectAtIndex:0])"></a>define CurrentLanguage (［NSLocale preferredLanguages] objectAtIndex:0])</h1><p>//判断是否 Retina屏、设备是否%fhone 5、是否是iPad</p>
<h1 id="define-isRetina-UIScreen-instancesRespondToSelector-selector-currentMode-CGSizeEqualToSize-CGSizeMake-640-960-［UIScreen-mainScreen-currentMode-size-NO"><a href="#define-isRetina-UIScreen-instancesRespondToSelector-selector-currentMode-CGSizeEqualToSize-CGSizeMake-640-960-［UIScreen-mainScreen-currentMode-size-NO" class="headerlink" title="define isRetina ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(640, 960), ［UIScreen mainScreen] currentMode].size) : NO)"></a>define isRetina ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(640, 960), ［UIScreen mainScreen] currentMode].size) : NO)</h1><h1 id="define-iPhone5-UIScreen-instancesRespondToSelector-selector-currentMode-CGSizeEqualToSize-CGSizeMake-640-1136-［UIScreen-mainScreen-currentMode-size-NO"><a href="#define-iPhone5-UIScreen-instancesRespondToSelector-selector-currentMode-CGSizeEqualToSize-CGSizeMake-640-1136-［UIScreen-mainScreen-currentMode-size-NO" class="headerlink" title="define iPhone5 ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(640, 1136), ［UIScreen mainScreen] currentMode].size) : NO)"></a>define iPhone5 ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(640, 1136), ［UIScreen mainScreen] currentMode].size) : NO)</h1><h1 id="define-isPad-UI-USER-INTERFACE-IDIOM-UIUserInterfaceIdiomPad-1"><a href="#define-isPad-UI-USER-INTERFACE-IDIOM-UIUserInterfaceIdiomPad-1" class="headerlink" title="define isPad (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad)"></a>define isPad (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad)</h1><p>//判断设备的操做系统是不是ios7</p>
<h1 id="define-IOS7-［-UIDevice-currentDevice-systemVersion-doubleValue-7-0"><a href="#define-IOS7-［-UIDevice-currentDevice-systemVersion-doubleValue-7-0" class="headerlink" title="define IOS7 (［[UIDevice currentDevice].systemVersion doubleValue] >= 7.0]"></a>define IOS7 (［[UIDevice currentDevice].systemVersion doubleValue] >= 7.0]</h1><p>//判断当前设备是不是iphone5</p>
<h1 id="define-kScreenIphone5-［UIScreen-mainScreen-bounds-size-height-568"><a href="#define-kScreenIphone5-［UIScreen-mainScreen-bounds-size-height-568" class="headerlink" title="define kScreenIphone5 ((［UIScreen mainScreen] bounds].size.height)>=568)"></a>define kScreenIphone5 ((［UIScreen mainScreen] bounds].size.height)>=568)</h1><p>//获取当前屏幕的高度</p>
<h1 id="define-kMainScreenHeight-UIScreen-mainScreen-applicationFrame-size-height"><a href="#define-kMainScreenHeight-UIScreen-mainScreen-applicationFrame-size-height" class="headerlink" title="define kMainScreenHeight ([UIScreen mainScreen].applicationFrame.size.height)"></a>define kMainScreenHeight ([UIScreen mainScreen].applicationFrame.size.height)</h1><p>//获取当前屏幕的宽度</p>
<h1 id="define-kMainScreenWidth-UIScreen-mainScreen-applicationFrame-size-width"><a href="#define-kMainScreenWidth-UIScreen-mainScreen-applicationFrame-size-width" class="headerlink" title="define kMainScreenWidth ([UIScreen mainScreen].applicationFrame.size.width)"></a>define kMainScreenWidth ([UIScreen mainScreen].applicationFrame.size.width)</h1><p>//定义一个define函数</p>
<h1 id="define-TT-RELEASE-CF-SAFELY-REF-if-nil-REF-CFRelease-REF-REF-nil"><a href="#define-TT-RELEASE-CF-SAFELY-REF-if-nil-REF-CFRelease-REF-REF-nil" class="headerlink" title="define TT_RELEASE_CF_SAFELY(REF) { if (nil != (REF)) { CFRelease(REF); REF = nil; } }"></a>define TT_RELEASE_CF_SAFELY(<strong>REF) { if (nil != (</strong>REF)) { CFRelease(<strong>REF); </strong>REF = nil; } }</h1><p>//判断是真机还是模拟器</p>
<h1 id="if-TARGET-OS-IPHONE"><a href="#if-TARGET-OS-IPHONE" class="headerlink" title="if TARGET_OS_IPHONE"></a>if TARGET_OS_IPHONE</h1><p>//iPhone Device</p>
<h1 id="endif-3"><a href="#endif-3" class="headerlink" title="endif"></a>endif</h1><h1 id="if-TARGET-IPHONE-SIMULATOR"><a href="#if-TARGET-IPHONE-SIMULATOR" class="headerlink" title="if TARGET_IPHONE_SIMULATOR"></a>if TARGET_IPHONE_SIMULATOR</h1><p>//iPhone Simulator</p>
<h1 id="endif-4"><a href="#endif-4" class="headerlink" title="endif"></a>endif</h1><p>//检查系统版本</p>
<h1 id="define-SYSTEM-VERSION-EQUAL-TO-v-［-UIDevice-currentDevice-systemVersion-compare-v-options-NSNumericSearch-NSOrderedSame"><a href="#define-SYSTEM-VERSION-EQUAL-TO-v-［-UIDevice-currentDevice-systemVersion-compare-v-options-NSNumericSearch-NSOrderedSame" class="headerlink" title="define SYSTEM_VERSION_EQUAL_TO(v) (［[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedSame)"></a>define SYSTEM_VERSION_EQUAL_TO(v) (［[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedSame)</h1><h1 id="define-SYSTEM-VERSION-GREATER-THAN-v-［-UIDevice-currentDevice-systemVersion-compare-v-options-NSNumericSearch-NSOrderedDescending"><a href="#define-SYSTEM-VERSION-GREATER-THAN-v-［-UIDevice-currentDevice-systemVersion-compare-v-options-NSNumericSearch-NSOrderedDescending" class="headerlink" title="define SYSTEM_VERSION_GREATER_THAN(v) (［[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedDescending)"></a>define SYSTEM_VERSION_GREATER_THAN(v) (［[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedDescending)</h1><h1 id="define-SYSTEM-VERSION-GREATER-THAN-OR-EQUAL-TO-v-［-UIDevice-currentDevice-systemVersion-compare-v-options-NSNumericSearch-NSOrderedAscending"><a href="#define-SYSTEM-VERSION-GREATER-THAN-OR-EQUAL-TO-v-［-UIDevice-currentDevice-systemVersion-compare-v-options-NSNumericSearch-NSOrderedAscending" class="headerlink" title="define SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(v) (［[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] != NSOrderedAscending)"></a>define SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(v) (［[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] != NSOrderedAscending)</h1><h1 id="define-SYSTEM-VERSION-LESS-THAN-v-［-UIDevice-currentDevice-systemVersion-compare-v-options-NSNumericSearch-NSOrderedAscending"><a href="#define-SYSTEM-VERSION-LESS-THAN-v-［-UIDevice-currentDevice-systemVersion-compare-v-options-NSNumericSearch-NSOrderedAscending" class="headerlink" title="define SYSTEM_VERSION_LESS_THAN(v) (［[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedAscending)"></a>define SYSTEM_VERSION_LESS_THAN(v) (［[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedAscending)</h1><h1 id="define-SYSTEM-VERSION-LESS-THAN-OR-EQUAL-TO-v-［-UIDevice-currentDevice-systemVersion-compare-v-options-NSNumericSearch-NSOrderedDescending"><a href="#define-SYSTEM-VERSION-LESS-THAN-OR-EQUAL-TO-v-［-UIDevice-currentDevice-systemVersion-compare-v-options-NSNumericSearch-NSOrderedDescending" class="headerlink" title="define SYSTEM_VERSION_LESS_THAN_OR_EQUAL_TO(v) (［[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] != NSOrderedDescending)"></a>define SYSTEM_VERSION_LESS_THAN_OR_EQUAL_TO(v) (［[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] != NSOrderedDescending)</h1><p>//———————-系统—————————-</p>
<h1 id="define-TICK-NSDate-startTime-NSDate-date-写在方法头尾，测试运行时间"><a href="#define-TICK-NSDate-startTime-NSDate-date-写在方法头尾，测试运行时间" class="headerlink" title="define TICK   NSDate *startTime = [NSDate date]     //写在方法头尾，测试运行时间"></a>define TICK   NSDate *startTime = [NSDate date]     //写在方法头尾，测试运行时间</h1><h1 id="define-TOCK-NSLog-”Time-f”-startTime-timeIntervalSinceNow"><a href="#define-TOCK-NSLog-”Time-f”-startTime-timeIntervalSinceNow" class="headerlink" title="define TOCK   NSLog(@”Time: %f”, -[startTime timeIntervalSinceNow])"></a>define TOCK   NSLog(@”Time: %f”, -[startTime timeIntervalSinceNow])</h1><h1 id="define-TimeGetCurrent-CFAbsoluteTimeGetCurrent-写在要测试代码片段头尾，两个相减算运行时间"><a href="#define-TimeGetCurrent-CFAbsoluteTimeGetCurrent-写在要测试代码片段头尾，两个相减算运行时间" class="headerlink" title="define TimeGetCurrent  CFAbsoluteTimeGetCurrent()  // 写在要测试代码片段头尾，两个相减算运行时间"></a>define TimeGetCurrent  CFAbsoluteTimeGetCurrent()  // 写在要测试代码片段头尾，两个相减算运行时间</h1><h1 id="define-AC-Assert-condition-NSAssert-condition-NSString-stringWithFormat-”file-name-s-—-function-name-s-at-line-d”-FILE-FUNCTION-LINE"><a href="#define-AC-Assert-condition-NSAssert-condition-NSString-stringWithFormat-”file-name-s-—-function-name-s-at-line-d”-FILE-FUNCTION-LINE" class="headerlink" title="define AC_Assert(condition) NSAssert(condition, ([NSString stringWithFormat:@”file name = %s —> function name = %s at line: %d”, FILE, FUNCTION, LINE]));"></a>define AC_Assert(condition) NSAssert(condition, ([NSString stringWithFormat:@”file name = %s —> function name = %s at line: %d”, <strong>FILE</strong>, <strong>FUNCTION</strong>, <strong>LINE</strong>]));</h1><p>//————————————————————</p>
<h1 id="define-CHECK-AlphaNum-”ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789”"><a href="#define-CHECK-AlphaNum-”ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789”" class="headerlink" title="define CHECK_AlphaNum   @”ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789”"></a>define CHECK_AlphaNum   @”ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789”</h1><h1 id="define-CHECK-Num-”0123456789”"><a href="#define-CHECK-Num-”0123456789”" class="headerlink" title="define CHECK_Num   @”0123456789”"></a>define CHECK_Num   @”0123456789”</h1><p>//———————-内存—————————-</p>
<p>//使用ARC和不使用ARC</p>
<h1 id="if-has-feature-objc-arc"><a href="#if-has-feature-objc-arc" class="headerlink" title="if __has_feature(objc_arc)"></a>if __has_feature(objc_arc)</h1><p>//compiling with ARC</p>
<h1 id="else-3"><a href="#else-3" class="headerlink" title="else"></a>else</h1><p>// compiling without ARC</p>
<h1 id="endif-5"><a href="#endif-5" class="headerlink" title="endif"></a>endif</h1><h1 id="pragma-mark-common-functions"><a href="#pragma-mark-common-functions" class="headerlink" title="pragma mark - common functions"></a>pragma mark - common functions</h1><h1 id="define-RELEASE-SAFELY-POINTER-POINTER-release-POINTER-nil"><a href="#define-RELEASE-SAFELY-POINTER-POINTER-release-POINTER-nil" class="headerlink" title="define RELEASE_SAFELY(POINTER) { [POINTER release]; __POINTER = nil; }"></a>define RELEASE_SAFELY(<strong>POINTER) { [</strong>POINTER release]; __POINTER = nil; }</h1><p>//释放一个对象</p>
<h1 id="define-SAFE-DELETE-P-if-P-P-release-P-nil"><a href="#define-SAFE-DELETE-P-if-P-P-release-P-nil" class="headerlink" title="define SAFE_DELETE(P) if(P) { [P release], P = nil; }"></a>define SAFE_DELETE(P) if(P) { [P release], P = nil; }</h1><h1 id="define-SAFE-RELEASE-x-x-release-x-nil"><a href="#define-SAFE-RELEASE-x-x-release-x-nil" class="headerlink" title="define SAFE_RELEASE(x) [x release];x=nil"></a>define SAFE_RELEASE(x) [x release];x=nil</h1><p>// 是否空对象</p>
<h1 id="define-IS-NULL-CLASS-OBJECT-OBJECT-isKindOfClass-NSNull-class"><a href="#define-IS-NULL-CLASS-OBJECT-OBJECT-isKindOfClass-NSNull-class" class="headerlink" title="define IS_NULL_CLASS(OBJECT) [OBJECT isKindOfClass:[NSNull class]]"></a>define IS_NULL_CLASS(OBJECT) [OBJECT isKindOfClass:[NSNull class]]</h1><p>//———————-内存—————————-</p>
<p>//———————-图片—————————-</p>
<p>//读取本地图片</p>
<h1 id="define-LOADIMAGE-file-ext-UIImage-imageWithContentsOfFile-［NSBundle-mainBundle-pathForResource-file-ofType-ext］"><a href="#define-LOADIMAGE-file-ext-UIImage-imageWithContentsOfFile-［NSBundle-mainBundle-pathForResource-file-ofType-ext］" class="headerlink" title="define LOADIMAGE(file,ext) [UIImage imageWithContentsOfFile:［NSBundle mainBundle]pathForResource:file ofType:ext］"></a>define LOADIMAGE(file,ext) [UIImage imageWithContentsOfFile:［NSBundle mainBundle]pathForResource:file ofType:ext］</h1><p>//定义UIImage对象</p>
<h1 id="define-IMAGE-A-UIImage-imageWithContentsOfFile-［NSBundle-mainBundle-pathForResource-A-ofType-nil］"><a href="#define-IMAGE-A-UIImage-imageWithContentsOfFile-［NSBundle-mainBundle-pathForResource-A-ofType-nil］" class="headerlink" title="define IMAGE(A) [UIImage imageWithContentsOfFile:［NSBundle mainBundle] pathForResource:A ofType:nil］"></a>define IMAGE(A) [UIImage imageWithContentsOfFile:［NSBundle mainBundle] pathForResource:A ofType:nil］</h1><p>//定义UIImage对象</p>
<h1 id="define-ImageNamed-pointer-UIImage-imageNamed-UIUtil-imageName-pointer］"><a href="#define-ImageNamed-pointer-UIImage-imageNamed-UIUtil-imageName-pointer］" class="headerlink" title="define ImageNamed(_pointer) [UIImage imageNamed:[UIUtil imageName:_pointer］"></a>define ImageNamed(_pointer) [UIImage imageNamed:[UIUtil imageName:_pointer］</h1><p>//可拉伸的图片</p>
<h1 id="define-ResizableImage-name-top-left-bottom-right-UIImage-imageNamed-name-resizableImageWithCapInsets-UIEdgeInsetsMake-top-left-bottom-right"><a href="#define-ResizableImage-name-top-left-bottom-right-UIImage-imageNamed-name-resizableImageWithCapInsets-UIEdgeInsetsMake-top-left-bottom-right" class="headerlink" title="define ResizableImage(name,top,left,bottom,right) [[UIImage imageNamed:name] resizableImageWithCapInsets:UIEdgeInsetsMake(top,left,bottom,right)]"></a>define ResizableImage(name,top,left,bottom,right) [[UIImage imageNamed:name] resizableImageWithCapInsets:UIEdgeInsetsMake(top,left,bottom,right)]</h1><h1 id="define-ResizableImageWithMode-name-top-left-bottom-right-mode-UIImage-imageNamed-name-resizableImageWithCapInsets-UIEdgeInsetsMake-top-left-bottom-right-resizingMode-mode"><a href="#define-ResizableImageWithMode-name-top-left-bottom-right-mode-UIImage-imageNamed-name-resizableImageWithCapInsets-UIEdgeInsetsMake-top-left-bottom-right-resizingMode-mode" class="headerlink" title="define ResizableImageWithMode(name,top,left,bottom,right,mode) [[UIImage imageNamed:name] resizableImageWithCapInsets:UIEdgeInsetsMake(top,left,bottom,right) resizingMode:mode]"></a>define ResizableImageWithMode(name,top,left,bottom,right,mode) [[UIImage imageNamed:name] resizableImageWithCapInsets:UIEdgeInsetsMake(top,left,bottom,right) resizingMode:mode]</h1><p>//建议使用前两种宏定义,性能高于后者<br>//———————-图片—————————-</p>
<p>//———————-颜色类—————————<br>// rgb颜色转换（16进制->10进制）</p>
<h1 id="define-UIColorFromRGB-rgbValue-UIColor-colorWithRed-float-rgbValue-amp-0xFF0000-16-255-0-green-float-rgbValue-amp-0xFF00-8-255-0-blue-float-rgbValue-amp-0xFF-255-0-alpha-1-0"><a href="#define-UIColorFromRGB-rgbValue-UIColor-colorWithRed-float-rgbValue-amp-0xFF0000-16-255-0-green-float-rgbValue-amp-0xFF00-8-255-0-blue-float-rgbValue-amp-0xFF-255-0-alpha-1-0" class="headerlink" title="define UIColorFromRGB(rgbValue) [UIColor colorWithRed:((float)((rgbValue &amp; 0xFF0000) >> 16))/255.0 green:((float)((rgbValue &amp; 0xFF00) >> 8))/255.0 blue:((float)(rgbValue &amp; 0xFF))/255.0 alpha:1.0]"></a>define UIColorFromRGB(rgbValue) [UIColor colorWithRed:((float)((rgbValue &amp; 0xFF0000) >> 16))/255.0 green:((float)((rgbValue &amp; 0xFF00) >> 8))/255.0 blue:((float)(rgbValue &amp; 0xFF))/255.0 alpha:1.0]</h1><p>//带有RGBA的颜色设置</p>
<h1 id="define-COLOR-R-G-B-A-UIColor-colorWithRed-R-255-0-green-G-255-0-blue-B-255-0-alpha-A"><a href="#define-COLOR-R-G-B-A-UIColor-colorWithRed-R-255-0-green-G-255-0-blue-B-255-0-alpha-A" class="headerlink" title="define COLOR(R, G, B, A) [UIColor colorWithRed:R/255.0 green:G/255.0 blue:B/255.0 alpha:A]"></a>define COLOR(R, G, B, A) [UIColor colorWithRed:R/255.0 green:G/255.0 blue:B/255.0 alpha:A]</h1><p>// 获取RGB颜色</p>
<h1 id="define-RGBA-r-g-b-a-UIColor-colorWithRed-r-255-0f-green-g-255-0f-blue-b-255-0f-alpha-a"><a href="#define-RGBA-r-g-b-a-UIColor-colorWithRed-r-255-0f-green-g-255-0f-blue-b-255-0f-alpha-a" class="headerlink" title="define RGBA(r,g,b,a) [UIColor colorWithRed:r/255.0f green:g/255.0f blue:b/255.0f alpha:a]"></a>define RGBA(r,g,b,a) [UIColor colorWithRed:r/255.0f green:g/255.0f blue:b/255.0f alpha:a]</h1><h1 id="define-RGB-r-g-b-RGBA-r-g-b-1-0f"><a href="#define-RGB-r-g-b-RGBA-r-g-b-1-0f" class="headerlink" title="define RGB(r,g,b) RGBA(r,g,b,1.0f)"></a>define RGB(r,g,b) RGBA(r,g,b,1.0f)</h1><p>//背景色</p>
<h1 id="define-BACKGROUND-COLOR-UIColor-colorWithRed-242-0-255-0-green-236-0-255-0-blue-231-0-255-0-alpha-1-0"><a href="#define-BACKGROUND-COLOR-UIColor-colorWithRed-242-0-255-0-green-236-0-255-0-blue-231-0-255-0-alpha-1-0" class="headerlink" title="define BACKGROUND_COLOR [UIColor colorWithRed:242.0/255.0 green:236.0/255.0 blue:231.0/255.0 alpha:1.0]"></a>define BACKGROUND_COLOR [UIColor colorWithRed:242.0/255.0 green:236.0/255.0 blue:231.0/255.0 alpha:1.0]</h1><p>//清除背景色</p>
<h1 id="define-CLEARCOLOR-UIColor-clearColor"><a href="#define-CLEARCOLOR-UIColor-clearColor" class="headerlink" title="define CLEARCOLOR [UIColor clearColor]"></a>define CLEARCOLOR [UIColor clearColor]</h1><h1 id="pragma-mark-color-functions"><a href="#pragma-mark-color-functions" class="headerlink" title="pragma mark - color functions"></a>pragma mark - color functions</h1><h1 id="define-RGBCOLOR-r-g-b-UIColor-colorWithRed-r-255-0f-green-g-255-0f-blue-b-255-0f-alpha-1"><a href="#define-RGBCOLOR-r-g-b-UIColor-colorWithRed-r-255-0f-green-g-255-0f-blue-b-255-0f-alpha-1" class="headerlink" title="define RGBCOLOR(r,g,b) [UIColor colorWithRed:(r)/255.0f green:(g)/255.0f blue:(b)/255.0f alpha:1]"></a>define RGBCOLOR(r,g,b) [UIColor colorWithRed:(r)/255.0f green:(g)/255.0f blue:(b)/255.0f alpha:1]</h1><h1 id="define-RGBACOLOR-r-g-b-a-UIColor-colorWithRed-r-255-0f-green-g-255-0f-blue-b-255-0f-alpha-a"><a href="#define-RGBACOLOR-r-g-b-a-UIColor-colorWithRed-r-255-0f-green-g-255-0f-blue-b-255-0f-alpha-a" class="headerlink" title="define RGBACOLOR(r,g,b,a) [UIColor colorWithRed:(r)/255.0f green:(g)/255.0f blue:(b)/255.0f alpha:(a)]"></a>define RGBACOLOR(r,g,b,a) [UIColor colorWithRed:(r)/255.0f green:(g)/255.0f blue:(b)/255.0f alpha:(a)]</h1><p>//———————-颜色类————————–</p>
<p>//———————-其他—————————-</p>
<p>//方正黑体简体字体定义</p>
<h1 id="define-FONT-F-UIFont-fontWithName-”FZHTJW–GB1-0”-size-F"><a href="#define-FONT-F-UIFont-fontWithName-”FZHTJW–GB1-0”-size-F" class="headerlink" title="define FONT(F) [UIFont fontWithName:@”FZHTJW–GB1-0” size:F]"></a>define FONT(F) [UIFont fontWithName:@”FZHTJW–GB1-0” size:F]</h1><p>//定义一个API</p>
<h1 id="define-APIURL-”http-xxxxx-“"><a href="#define-APIURL-”http-xxxxx-“" class="headerlink" title="define APIURL @”http://xxxxx/“"></a>define APIURL @”<a href="http://xxxxx/" target="_blank" rel="external">http://xxxxx/</a>“</h1><p>//登录API</p>
<h1 id="define-APILogin-APIURL-stringByAppendingString-”Login”"><a href="#define-APILogin-APIURL-stringByAppendingString-”Login”" class="headerlink" title="define APILogin [APIURL stringByAppendingString:@”Login”]"></a>define APILogin [APIURL stringByAppendingString:@”Login”]</h1><p>//设置View的tag属性</p>
<h1 id="define-VIEWWITHTAG-OBJECT-TAG-OBJECT-viewWithTag-TAG"><a href="#define-VIEWWITHTAG-OBJECT-TAG-OBJECT-viewWithTag-TAG" class="headerlink" title="define VIEWWITHTAG(_OBJECT, _TAG) [_OBJECT viewWithTag : _TAG]"></a>define VIEWWITHTAG(_OBJECT, _TAG) [_OBJECT viewWithTag : _TAG]</h1><p>//程序的本地化,引用国际化的文件</p>
<h1 id="define-MyLocal-x-…-NSLocalizedString-x-nil"><a href="#define-MyLocal-x-…-NSLocalizedString-x-nil" class="headerlink" title="define MyLocal(x, …) NSLocalizedString(x, nil)"></a>define MyLocal(x, …) NSLocalizedString(x, nil)</h1><p>//G－C－D</p>
<h1 id="define-BACK-block-dispatch-async-dispatch-get-global-queue-DISPATCH-QUEUE-PRIORITY-DEFAULT-0-block"><a href="#define-BACK-block-dispatch-async-dispatch-get-global-queue-DISPATCH-QUEUE-PRIORITY-DEFAULT-0-block" class="headerlink" title="define BACK(block) dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), block)"></a>define BACK(block) dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), block)</h1><h1 id="define-MAIN-block-dispatch-async-dispatch-get-main-queue-block"><a href="#define-MAIN-block-dispatch-async-dispatch-get-main-queue-block" class="headerlink" title="define MAIN(block) dispatch_async(dispatch_get_main_queue(),block)"></a>define MAIN(block) dispatch_async(dispatch_get_main_queue(),block)</h1><p>//NSUserDefaults 实例化</p>
<h1 id="define-USER-DEFAULT-NSUserDefaults-standardUserDefaults"><a href="#define-USER-DEFAULT-NSUserDefaults-standardUserDefaults" class="headerlink" title="define USER_DEFAULT [NSUserDefaults standardUserDefaults]"></a>define USER_DEFAULT [NSUserDefaults standardUserDefaults]</h1><p>//由角度获取弧度 有弧度获取角度</p>
<h1 id="define-degreesToRadian-x-M-PI-x-180-0"><a href="#define-degreesToRadian-x-M-PI-x-180-0" class="headerlink" title="define degreesToRadian(x) (M_PI * (x) / 180.0)"></a>define degreesToRadian(x) (M_PI * (x) / 180.0)</h1><h1 id="define-radianToDegrees-radian-radian-180-0-M-PI"><a href="#define-radianToDegrees-radian-radian-180-0-M-PI" class="headerlink" title="define radianToDegrees(radian) (radian*180.0)/(M_PI)"></a>define radianToDegrees(radian) (radian*180.0)/(M_PI)</h1><p>//单例化一个类</p>
<h1 id="define-SYNTHESIZE-SINGLETON-FOR-CLASS-classname"><a href="#define-SYNTHESIZE-SINGLETON-FOR-CLASS-classname" class="headerlink" title="define SYNTHESIZE_SINGLETON_FOR_CLASS(classname) \"></a>define SYNTHESIZE_SINGLETON_FOR_CLASS(classname) \</h1><p>\<br>static classname *shared##classname = nil; \<br>\</p>
<ul>
<li>(classname *)shared##classname \<br>{ \<br>@synchronized(self) \<br>{ \<br>if (shared##classname == nil) \<br>{ \<br>shared##classname = ［self alloc] init]; \<br>} \<br>} \<br>\<br>return shared##classname; \<br>} \<br>\</li>
<li>(id)allocWithZone:(NSZone *)zone \<br>{ \<br>@synchronized(self) \<br>{ \<br>if (shared##classname == nil) \<br>{ \<br>shared##classname = [super allocWithZone:zone]; \<br>return shared##classname; \<br>} \<br>} \<br>\<br>return nil; \<br>} \<br>\</li>
</ul>
<ul>
<li>(id)copyWithZone:(NSZone *)zone \<br>{ \<br>return self; \<br>}</li>
</ul>
<h1 id="endif-6"><a href="#endif-6" class="headerlink" title="endif"></a>endif</h1>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;iOS常用宏定义&quot;&gt;&lt;a href=&quot;#iOS常用宏定义&quot; class=&quot;headerlink&quot; title=&quot;iOS常用宏定义&quot;&gt;&lt;/a&gt;iOS常用宏定义&lt;/h3&gt;&lt;h1 id=&quot;ifndef-MacroDefinition-h&quot;&gt;&lt;a href=&quot;#ifnde
    
    </summary>
    
      <category term="Developer" scheme="http://www.jeyblogs.com/categories/Developer/"/>
    
    
      <category term="宏定义" scheme="http://www.jeyblogs.com/tags/%E5%AE%8F%E5%AE%9A%E4%B9%89/"/>
    
  </entry>
  
  <entry>
    <title>Xcode常用快捷键，网上找的总结一下，特别是格式化代码</title>
    <link href="http://www.jeyblogs.com/2013/08/12/Xcode%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%EF%BC%8C%E7%BD%91%E4%B8%8A%E6%89%BE%E7%9A%84%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%EF%BC%8C%E7%89%B9%E5%88%AB%E6%98%AF%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BB%A3%E7%A0%81/"/>
    <id>http://www.jeyblogs.com/2013/08/12/Xcode常用快捷键，网上找的总结一下，特别是格式化代码/</id>
    <published>2013-08-12T08:06:36.000Z</published>
    <updated>2016-08-30T09:59:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>隐藏xcode command+h<br>退出xcode command+q<br>关闭窗口 command+w<br>关闭所有窗口 command+option+w<br>关闭当前项目 command+control+w<br>关闭当前文件 command+shift+w<br>保存文件 command+s<br>保存所有文件 command+option+s<br>还原到保存时状态 command+u<br>项目中查找 command+shift+F<br>查找下一个 command+g<br>查找上一个 command+shift+g<br>浏览源文件 command+Double Click<br>打开头文件 command+shift+d<br>切换头/源文件 command+option+上箭头</p>
<p>撤销 command+z<br>重复 command+shift+z<br>剪切 command+x<br>复制 command+c<br>粘贴 command+v<br>粘贴并匹配格式 command+option+shift+v<br>全选 command+a<br>注释 command+/<br>文件首行 command+上箭头<br>文件末 command+下箭头<br>行首 command+左箭头<br>行末 command+右箭头<br>上一单词 option+左箭头<br>下一单词 option+右箭头<br>上一拆分单词 control+左箭头<br>下一拆分单词 control+右箭头<br>Tab ：接受代码提示<br>Esc ：显示代码提示菜单<br>下个Build警告或错误 command+=<br>前个Build警告或错误 command+shift+=<br>以调试方式运行程序 command+y<br>继续（在调试中）command+option+p<br>编译运行 command+r</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;隐藏xcode command+h&lt;br&gt;退出xcode command+q&lt;br&gt;关闭窗口 command+w&lt;br&gt;关闭所有窗口 command+option+w&lt;br&gt;关闭当前项目 command+control+w&lt;br&gt;关闭当前文件 command+shift+w
    
    </summary>
    
      <category term="工具" scheme="http://www.jeyblogs.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="xcode" scheme="http://www.jeyblogs.com/tags/xcode/"/>
    
  </entry>
  
</feed>
